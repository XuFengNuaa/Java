1. > **面向对象和面向过程的区别？**

   什么是OOP ？  **万物皆对象**    

   将事物的==属性==和==功能==抽象出来并封装到对象中。需要实现某一功能，让相应的对象去完成即可。

   eg . 把大象装进冰箱中    抽出对象 ： 大象  冰箱   功能 ： 大象(进冰箱)  冰箱(开门  关门)

   **面向对象和面向过程的区别？**

   - 面向过程 ： 【将问题抽成一个个方法去执行。】性能比面向对象高。不用实例化对象。

     ​                     不易维护、扩展和复用

   - 面向对象 ： 易维护、易扩展、易复用 。面向对象的三大特性 ： 封装、继承、多态 可以设计出低耦合性的系统，是系统      

     ​                   更灵活。

2. >  **java语言的特点     和  C++的区别**

   面向对象 、平台无关性、可靠安全型、支持多线程、支持网络编程且很方便

   都是面向对象的语言。 Java不提供指针来直接访问内存，程序内存更加安全 ； Java类只能单继承，C++可以多继承

   Java有自动内存管理机制

   

3. > **字符型常量和字符串常量 ？** 

   > **基本数据类型 ： byte   short   int   long   float  double    char(字符型)** 
   >
   > - **byte:   1个字节，-128-127  defeat : 0**       8 bits
   > - **short:  2个字节，-2^15 -- 2^15-1   defeat : 0 **    16 bits
   > - **int :     4个字节， -2^31-- 2^31-1   defeat : 0**
   > - **long:   8个字节 ， -2^63 -- 2^63-1  defeat : 0L**
   > - **float:   4个   默认值是 0.0f**
   > - **double:  8个  默认值是 0.0d**
   > - **char  2个字节** 

   形式上 : **字符**常量是==单引号==引起的一个字符，**字符串**常量是==双引号==引起的若干个字符

   含义上：字符常量相当于一个整型值(ASCII 值)，可以参与表达式运算 ；字符串常量代表一个地址值(该字符串在内存中的位置)。



4. > **方法的重载和重写的区别**   重载发生在==编译==期间  重写发生在==运行==期间

   - **重载(overloading)** ：   构造函数可以重载，但不能重写 。  一个类可以有多个构造函数
     - 发生在==同一类==中，方法名==必须相同==，参数类型、个数的不同；返回值类型可以不同。
     - 通过参数类型决定使用哪个方法 ； ==**无法通过返回值类型区别重载函数**==
   - **重写(overriding)** :
     - 对父类方法的重新定义。子类继承父类==相同的方法==，具有==相同的参数类型和返回值==。则父类的方法将被覆盖
     - 抛出异常的范围小于父类方法 ； ==修饰符范围==要==**大于**==父类方法
     - 父类的  `private/static/final` 修饰的方法，==不能被重写== 。 但是被static的方法能被再次声明 。

   ==构造方法==的特性 ： 方法名和类名相同  ； 没有返回值 ； 生成对象时自动执行

5. >   **Java的三大特性 ： 封装、继承、多态**

   - **封装**

     把对象的==属性私==有化private，外部通过提供==get/set==方法访问

   - **继承**

     extends ,  在已有类的基础上新生的类，==继承==了父类中定义的所有实例变量和方法， 并且增加了独特的元素

     **private私有**无法被继承 ，==final==声明类，==不能==被继承 。   只有==**单继承**==

   - **多态** 

     > **多态的三个前提条件：**
     >
     > - **有继承关系**
     > - **子类重写父类的方法**
     > - **父类引用指向子类对象**

     对象能执行什么方法，主要看==**左边**==的类型

     **多态==弊端==** ：  `多态后不能使用子类特有的方法和属性`

     **父类引用指向子类对象**
     使用多态方式调用方法时，首先检查**==父类==**中是否有该方法，如果有，再去调用==子类的同名方法==；如果没有，则编译错误。



6. > **String StringBuffer  StringBuilder 的区别是什么 ？String 为什么是不可变的？**

   - String类中使用 ==**final**== 关键字修饰字符数组来保存字符串   `private fianl char  value[]`  ,所以String是==**不可变**==的

     final 修饰  ：  基本类型 一旦初始化，==值不变== 。  引用类型的变量==不能指向==另外一个对象

   - StringBuffer ： 用char value[] 字符数组来保存，但是没有用final 修饰，所以StringBuffer 和 StringBuilder 都是可变的

     StringBuffer是==线程安全==的 【对其方法加了同步锁，用 ==**synchronized**==修饰的】

   - StringBuilder  : 底层也是字符数组来保存的  char value[]  ，但是其方法没有加同步锁，线程不安全

​       总结  ：  每次对 String 类型 进行改变的时候 ，都会生成一个新的String对象 并将指针指向新的String对象

​					 StringBuffer 每次会对StringBuffer本身进行操作 。 相同情况下，==StringBuilder性能比StringBuffer好==，但是线性

​					 不安全 。 



7. >  **是否在static环境中访问非static变量？**

   不能。静态的成员变量属于==类== ，随着类的加载而加载到静态方法区内。在类加载的时候，此时不一定有实例创建，没有实例，==变量就没有初始化== ，就不能访问非静态成员变量 。 类的加载优于实例的创建 。 



8. >  **==接口== 和 ==抽象类==的 区别**

   **抽象类**是对某一类==**事物**==的抽象  ；  **接口**是对==动作==的抽象

   只能继承一个类 ，但是可以有多个动作 ，实现多个接口

   1. 接口(没有构造函数)和抽象类不能被==实例化==

   2. 抽象类可以指向==子类对象== ，这个对象必须继承抽象类并且实现所有的抽象方法 。同理，接口可以指向子类对象，但是必须实现所有的接口方法

      <img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2139861116,2509584885&amp;fm=173&amp;app=49&amp;f=JPEG?w=500&amp;h=290&amp;s=CA43DF10B9DE71C84EEC555E030010F1" alt="img" style="zoom:67%;" />

   3. 接口只对方法进行声明 ，所有的方法是抽象的 ；抽象类可以声明也可对方法进行实现

   4. 接口方法只能是`public` ，公共访问 ; 常量 是 `static final` 。 抽象方法 可以是`public  protected default` 

   5. 如果子类==不能==实现所有的抽象类或接口方法，这个类必须是==抽象==的

   

9. >   **静态方法 和  实例方法有何不同**

   1. **静态**方法可以直接通过 ”**类名. 方法**“ ；也可以使用”**对象名. 方法**“ 。实例方法只能==先 创建对象== ，通过后者调用
   2. 静态方法中==只能访问静态成员==(静态变量 和 静态方法) ； 不允许访问实例成员变量和方法



10. >  **==== 和 equals==**

    ```java
    1）对于==， 运算符 。比较的是值是否相等
    
           如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；
    
    　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址
        
    2）对于equals方法，注意：只适用引用数据类型,  比较的是是否是同一个对象
        	
    　　　　如果没有对equals方法进行重写，(Object 中的 equals 和 == 是一样的 , 比较两个地址的值是否一样)
        	则比较的是对象的地址；
    
    　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容，相等返回true。
    ```

11. >  **==equals  和 hashCode==**

    为什么重写equals 时必须重写 hashCode方法

    以"**hashSet如何检查重复**"为例子  :  当要把对象加入HashSet时，会先计算HashCode值来判断对象加入的位置 。看该位置上是否有元素 ： 没有元素就添加成功。 如果有元素，就比较两个的哈希值，哈希值不同就添加成功。哈希值相同就再次比较equals是否相同，返回true；添加失败；false，添加成功 。 这样大大较少了equals比较的次数，提高了执行的速度。

    > 相关的规定 :
    >
    > 1. **两个对象相等，hashcode 一定也相同**
    > 2. **两个对象相等，equals返回true**
    > 3. **两个对象有相同的hashcode，它们不一定相等**
    > 4. **equals重写，hashcode应相等**



12. > **进程和线程** 

    进程 :  是==程序==的一次执行过程，是系统运行程序的基本单位。每个进程是一个执行中的程序。

    线程：线程是进程划分的==更小==的运行单位。一个进程在执行的过程中会产生很多线程。

    线程和进程的==最大区别== ： 

    > **各个进程相互独立，而线程不一定，同一进程中的线程可能相互影响 。同一时段可能执行多个程序，而线程是同一程序同时执行一个程序段 。**



13. > **==final==关键字的总结**

    - 修饰**变量** ： 对于基本数据类型 ，一旦初始化不能改变；对与引用类型，初始化后不能指向另一个对象
    - 修饰**类** ： 该类不能被继承。类中的成员方法被指定为final 方法
    - 修饰**方法** ： 该方法可以被继承，但不能重写 

    

14. > **线程的基本状态**

    new  Runnable  wait  destory  blocked wait_delay

15. >  **java序列化中如果有些字段不想进行序列化，怎么办？**

    利用关键字 ==**transient**==；当对象被反序列化时，被 transient修饰的变量值不会被 持久化 和恢复 。

    transient ==只==修饰 ==变量== ，不能修饰类和方法 。



## Java集合框架

1. > **数组 和 ArrayList 的区别**

   数组可以包含基本类型和引用类型     ArrayList 只能是对象的类型

   数组的大小固定，高效 ； ArrayList 大小可变化，牺牲效率



2. > **List 、Set 、Map**

   List ：有序的对象【是否按照==元素添加的顺序==来存储对象】
   
   Set：  不允许重复  比较hashcode  equals
   
   Map:  键值对存储 ，key不能**==重复==**
   
   
   
3. > **ArrayList 和  LinkedList 区别？**

   - 线程两者都不安全
   - ArrayList底层是用Object[]数组实现， 而 LinkedList 底层是双向链表实现的
   - 链表对频繁的插入和删除更加高效
   - ArrayList 支持快速随机访问 ，linkedList 不支持随机访问



4. >  **ArrayList的扩容机制** 

   初始的时刻是容量为 10 的空数组【真正添加第一个元素时，才分配容量】 ；每次扩容是原来的 1.5 倍 。

   ```java
   elementData[size++] = e  // 不是原子性操作   多线程状态下，不安全，会发生数组越界问题
   ```

   扩容是利用`System.arraycopy()` 和 `Arrays.copyOf()`方法 

   两者的区别是： CopyOf 内部实际是调用了System.arraycopy()方法

   - System.arraycopy()  :  需要目标数组 ，将原数组拷贝到自己定义的数组或者原数组中
   - CopyOf ： 内部自动新建一个数组，并返回



5. > **HashMap和 hashtable的区别**

   - HashMap线程不安全，Hashtable内部的方法经过`synchronized`修饰。【concurrentHashMap线程安全】
   - 由于线程安全问题，hashMap效率更高；不建议使用 hashtable
   - Hashmap 不支持 null 的key ，hashtable支持 null的key
   - 底层数据结构 ： hashMap  数组+链表+红黑树



6. >  **HashMap的长度为什么是2的幂次方**

   计算key对应的数组的下标

   先对数组的长度取模运算，得到的余数才是对应数组下标。   计算方法是(n - 1) & hash   ==**计算数组下标**==

   一是 2的n次方 -1 的 二进制后面是 ==n个1== ，& 运算能减少 碰撞几率 ，提高效率
   
   二是位运算能**==提高效率==** ，在 长度是 ==2的幂次方==下 【hash%length = hash &（length -1】 **取余效率低**



7. >  **concurrentMap 的原理**

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907215710570.png" alt="image-20200907215710570" style="zoom:50%;" />

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907215741188.png" alt="image-20200907215741188" style="zoom:50%;" />

   能够实现线程安全 (==**重要**==)： 

   - jdk 1.7   concurrentMap 是 采用的 **分段锁**，将整个数组进行分割成一个个 Segment ，Segment里面又包含着HashEntry数组 ，每个Entry是一个==链表==结构的元素 ，当对 HashEntry 的数据进行修改的时候 ，必须获得**==Segment 锁==**
     -  Segment 锁是可重入锁 ，继承了ReentrantLock 锁
   - jdk 1.8   取消了Segment ， 采用 synchronized  和 CAS 保证并发。 数据结构是  ==数组 +红黑树==
     -  synchronized 锁的是当前==**链表或红黑树的首节点**== ， 只要hash 不冲突 ，就不会产生并发 ，效率非常高。





## JUC多线程

1. > **线程和进程**

   进程 ： 是系统运行程序的最小单位。 一个进程代表一个程序在运行。

   线程 :    是进程划分的更小的运行单位 。 每个进程中有多个线程，并且每个线程间可能相互影响。

   每个线程间共享==堆和方法区== 。

 

​		并发编程的本质 ：  ==充分提高CPU的利用率==



2. >  **线程 的基本状态** 

   -  new  ： 线程的创建状态 
   - Runnable ：  运行状态。 线程创建之后，调用 start 方法，进入准备状态，当获得CPU时间片之后，进入 Runnable状态
   - Blocked  :  阻塞状态 ； 当线程调用同步方法，在==没有获得锁==的情况下 ， 进入**阻塞**状态
   -  wait  :  等待状态    ： 执行wait()  方法后  进入等待状态 ，直到被其他线程唤醒才能进入运行状态
   - time_wait :  超时等待  ：  在wait的基础上增加超时限制 。当到达时间后，线程返回 运行状态
   - Terminated :  线程执行完毕后 ， 进入终止状态



3. >   **死锁** 

   程序的运行期间 ，两个或多个线程都在相互等待对方持有的资源；相互阻塞导致死锁

   死锁的条件 :

   > 1. **互斥条件  :  该资源任一时刻只能被一个线程持有**
   > 2. **请求与保持条件 ： 一个因请求条件阻塞，对持有得资源保持不放**
   > 3. **不剥夺条件 ： 线程已经获得的资源在==未完成使用==的条件下==不能==被其他线程强行剥夺，只有自己释放资源**
   > 4. **循环等待条件 :  若干进程之间形成一个头尾相连的循环等待资源的关系**

   对比上述的条件 来避免死锁 ：  

   >   **占用资源的线程进一步申请其他资源的时候 ， 如果申请不到 ，就释放自身占有的资源**
   >
   >   **线程按某一顺序来申请资源，破坏循环等待的条件**



4. >  **wait  和 sleep 的区别**

   1. 来自不同的类  ；    Object .wait()    Thread  .sleep
   2.  wait  方法==释放锁== ，sleep  ==不会释放锁==
   3.  wailt 不需要捕获异常  ，  sleep  需要捕获 中断异常
   4.  wait 需要别的线程调用  notify() 唤醒进入等待队里 。  或者超时等待，超时后自动苏醒。sleep时间结束后自动苏醒



5. > **为什么 调用 start() 方法时会自动执行run 方法 ？ 为什么不能直接调用run方法** 

   new 一个 Thread ， 线程进入新建状态。 调用 start() 方法 ，==会启动一个线程，使线程进入准备状态==。当分配到时间片之后，就会正式运行了。  start（）进行线程的准备工作，然后自动执行 run 方法 ，真正多线程工作 。

   而直接运行 run 方法 ，==main==主线程==会直接执行==，并不会在某个线程中执行 ，这并不是多线程工作。



6. >  **synchronized 的应用方式**

   1.  修饰 ==实例==方法   ：   谁调用锁的就是谁   锁的是那个对象
   2.  修饰==静态==方法  ： 锁的是当前的的class 对象 ，这个类
   3.  修饰的是代码块 ：  给==指定的对象==加锁 ，调用之前需要获得锁  
   
   

7. >  **创建线程的方式**

   - 继承Thread 类

     - 自定义线程类继承==Thread类==

     - 重写==run()==方法，编写执行体

     - 创建线程对象，调用==start()==方法启动线程

     - ==**有局限性，一个对象不能被多个线程使用**==

       ```java
       public class TestThread extends Thread{
           //1:继承thread类，重写run方法，start（）启动
           @Override
           public void run() {
               for (int i = 0; i < 5; i++) {
                   System.out.println("线程"+i);
               }
           }
       
           public static void main(String[] args) {
               TestThread testThread = new TestThread();
               testThread.start();
               for (int i = 0; i < 10; i++) {
                   System.out.println("我学习线程"+i);
               }
           }
       }
       ```

   - 实现Runnable接口

     - ==实现Runnable接口==

     - 重写==run()==方法，编写执行体  ； **无返回值**

     - 创建线程对象，调用==start()==方法启动线程

     - **==推荐使用，灵活方便，一个对象可以被多个线程使用！==**

       ```java
       public class MyRunnable implements Runnable{
       
           @Override
           public void run() {
               for (int i = 0; i < 5; i++) {
                   System.out.println("线程"+i);
               }
           }
       
           public static void main(String[] args) {
               MyRunnable myRunnable = new MyRunnable();
               new Thread(myRunnable).start();
               for (int i = 0; i < 10; i++) {
                   System.out.println("我学习线程"+i);
               }
           }
       }
       	
       ```

   - 实现Callable 接口

     有返回值，可以抛出异常  ； 重写 ==call()==  方法

     使用 FutureTask 使用callable 接口

     <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200905202435453.png" alt="image-20200905202435453" style="zoom: 67%;" />



​		

8. >  **ReetranLock 和 synchronozed的区别**

   两者都是==可重入锁==

   **可重入锁** ：当第一次调用同步方法 ，获得了对象 的锁。当同一个线程再次调用该类中的其他方法，不会阻碍其运行。也即是

   ​					==同一线程可以多次获得同一把锁==。  也即==**可重入**==

   - 实现的原理 ： 每个锁关联着一个**持有者**和**计数器**。初始计数器为0；任何线程都可获得锁；其他线程想获得锁就等待；当前线程向再次获得该锁时，计数器+1 ；。当前线程执行完毕；计数器-1；直到==减到0==；释放锁。

   两者的区别 :  

   - synchronized 关键字，lock是接口
   - synchronized 自动获取锁，无法获得锁的状态 。 lock 可以通过 `lock.tryLock()` 尝试获取锁。
   - synchronized ==自动释放==锁 ， lock必须在finally 中==释放锁== ，否则造成死锁
   - synchronized 可重入 ，不可中断，非公平锁； lock 可重入，可中断；==两个重载函数，可公平，可非公平==
   - synchronized 与notify()/notifyAll() 实现线程间通信 ； lock 通过 condition接口实现通信 。 可实现==**精准唤醒**==



9. >  **阻塞队列 和 同步队列**

   BlockQueue  阻塞队列 

   先进先出 ； 使用 多线程并发处理 ，==**线程池**== 

   队列满了，必须阻塞 ；  队列为空，也需要阻塞

   SynchronizedQueue  同步队列

   ==只能==进去==一个==元素，出来之后才能进去另一个



10. > **线程池**

    池化技术  ： 实现准备好资源，有人来就直接用；用完之后再返回

    **优势** : 

    -  **降低系统的资源消耗** ： 降低频繁的创建和销毁线程；消耗资源
    -  **提高系统的响应速度** ： 当任务到达，直接使用资源，无需重新创建
    -  **方便线程的管理** ：  无限制的创建线程 ，可能会导致==OOM==问题。

    线程的==七大==参数 :

    ```java
    public ThreadPoolExecutor(  int corePoolSize   //  核心线程的个数
                                int maximumPoolSize, //  最大线程数
                                long keepAliveTime,  //  超时时间，超过时间就释放资源
                                TimeUnit unit,  //  超时时间单位
                                BlockingQueue<Runnable> workQueue,  // 阻塞队列 
                                ThreadFactory threadFactory, // 线程工厂 一般默认的工厂
                                RejectedExecutionHandler handler) // 拒绝策略
    ```

    ==四大==拒绝策略：

    - ThreadPoolExecutor.AbortPolicy  ： 当任务超过限制，直接==抛出==异常
    - ThreadPoolExecutor.CallerRunsPolicy   怎么来的怎么回去；调用执行自己的线程去运行任务
    - ThreadPoolExecutor.DiscardPolicy    ：  直接丢弃
    - ThreadPoolExecutor.Discard==Old==estPolicy  ： 丢弃==最早==的==未被处理==的执行任务请求



11. > **volatile**  轻量级的同步机制

    保证可见性  不保证原子性     进制指令重排  

    

​	  ==JMM==    java 内存模型

​	  每个变量存在==主内存==之中 ，每个线程有自己的工作内存(存储主内存中的==变量副本==) ；线程==不能==直接==操作主内存==的值

- 每个线程==无法直接==访问对方内存的值

<img src="https://upload-images.jianshu.io/upload_images/14923529-55ffcf1994434a48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img" style="zoom: 50%;" />

 内存有8中操作 ：   read  load  use  assign  write  store  lock  unlock

 **保证可见性**

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200906183012106.png" alt="image-20200906183012106" style="zoom: 60%;" />

 **不保证**原子性 ： 怎么解决？？  

1.  使用 synchronized  和 lock  
2.  使用 原子类   `concurrent atomic`

   原子类的底层操作  是直接在内存中修改 ； ==**Unsafe**== 是个特殊的存在 ，直接==操作内存==

禁止指令重排

​	指令重排 ： 写的程序，计算机==并不是==按照我们写的==顺序执行==的

​	采用volatile  ： 由有==**内存屏障**== ， 可以避免指令重排现象



12. >  **深入理解 CAS**    原子类

    CompareAndSwap ：  比较和交换    底层是Unsafe     对==**内存**==操作，效率很高

    ```java
    atomicInteger.compareAndSet(int expect , int update);   // 比较并交换
    ```

     **==unsafe  类==**   java无法操作内存 ， 底层调用C++操作内存



 CAS ： 拿到内存中的值；与期望值比较，如果这个值是期望的值，就执行update方法！  不是，就==**一直循环 (自旋锁)**==，直到成功

​			**调用的是本地方法 ， 拿到“旧的值”的==内存地址==，与预期值比较。**

 **缺点** ： 一直循环，开销大 ；  只能保证一个变量的原子操作  ； ABA问题

​	ABA 问题的解决 :  

​	使用原子引用类 `AtomicStampedReference`；乐观锁的思想 ； 给数据==标记版本号==，保证CAS的正确性



​	`java.util.concurrent.atomic`

​	JUC 包下的原子类 ： AtomicInteger  AtomicLong  AtomicBoolean

​		AtomicIntegerArray   AtomicLongArray  AtomicReferenceArray

​		AtomicReference  AtomicStampedReference  等等



13. >    **AQS  队列同步器**	

    当一个线程获取了某一资源 ，该资源被锁定；如果有后续的线程想要获得该资源，就==必须等待==。这就需要一个**线程阻塞等待和被唤醒时锁的分配机制** 。将 等待的线程放入队列中。

    原理 :   ==head== 记录队列的 头结点   ==tail== 记录尾节点    volatile  ==state== 记录 状态值 。

    当A 获得资源，将state =1 ；当其他线程B来获取资源时 ， state =1 ；将B的信息构建一个Node ，记录state  preNode next 节点 ，依次进行 。 直到A释放资源 ， 将state  =0 ；此时唤醒 后面的等待节点B ， 此时节点B ==获得锁==，==出队列== 。

    ​							 <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200906222444855.png" alt="image-20200906222444855" style="zoom:67%;" />	



14. > **ThreadLocal** 

    使用局部变量实现线程同步      //使用ThreadLocal类管理==共享变量==account

    如果使用==ThreadLoca==l管理变量，则每一个使用该变量的线程都获得该**变量的**==副本==，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

    他们可以使⽤ get（） 和 set（） ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。

    ThreadLocal 会造成==**内存泄漏**== ！



## JVM

1. >   **内存区域**

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907091022082.png" alt="image-20200907091022082" style="zoom:50%;" />

   <img src="I:\KSDownload\JVM1.png" style="zoom: 67%;" />

   线程共享 ： **堆  方法区(永久代)  元空间**

   线程私有 ：  栈  本地方法栈   程序计数器

   程序计数器的功能  :

   -  ==记录程序==执行到哪儿 ，方便线程切换后能继执行 
   -  通过改变程序计数器来依次读取指令 ，实现代码的==流程控制==

   

   ==**堆**== ：存放实例对象  ； 细分 ： **新生代(Eden、form 、to) 、老年代**。 

   ==元空间==取代永久代，不在虚拟机内，存在==本地内存==中

   JDK1.7之后  ： ==字符串常量池==从永久带剥离，存放到**堆**

   异常  :   stackOverFlower  OOM

   

2. >   **==**新生区==(Eden、幸存区(survial))==  老年区==**    ==堆==里面的分区**

   堆内存的分配

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907092718197.png" alt="image-20200907092718197" style="zoom:67%;" />

   **新生区包括  :  Eden  from区   To区**   

   新生对象首先在Eden区分配 ， 在经过一次GC后 ，将存活的对象和from中存储的对象转移到 To 区，清空Eden和From区，

   接着from 变为to ，to变为form (==谁空谁为to==) 。  每经过一次GC ，存活对象的年龄+1 ；经过15次还存活的直接进去老年区。

   `XX:MaxTenuringThreshold `  改变15 的限制

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907093509350.png" alt="image-20200907093509350" style="zoom:50%;" />



3. >  **Mirror GC 和  Full GC的区别？**

   大多数情况下 ，对象分配在 Eden  区 ，当Eden区没有足够的空间时，发生一次 Mirror GC 。

   - **新生代GC(Mirror GC)** ： 新生代的垃圾回收，频率较高，速度快
   - **老年代GC (Full GC)** ： 发生在老年代的GC ；速度比Mirror GC 慢的多



4. >  **如何判断对象已经死亡？**

   ==堆==内存中放着许多 ==对象的实例==， 在GC 之前要判定那些对象已经死亡，才能回收掉

   1. **引用计数法**

      给对象加上有引用计数 ，有引用的地方就+1 ； 当为0时，代表没有被引用

   2. **可达性分析算法**

      通过一系列的GC ROOT 对象 ，从==Root== 起点向下搜索，路径是一条引用链，当一个对象到Root ==**没有引用链**==的时候，就是无用对象。

      <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907095024628.png" alt="image-20200907095024628" style="zoom:50%;" />

      常见的root对象 ：   两个栈 和两个方法区

      > 1. 虚拟机栈的引用对象
      > 2. 方法区的静态属性引用对象
      > 3. 方法区中常量的引用对象
      > 4. 本地方法栈的引用对象

​			 

5. >  **强引用  软引用   弱引用  虚引用**

   **强引用** ： 理解为生活中**必不可少**的生活品 。   普遍引用都是==强引用== ，GC不会回收它，当内存溢出时 ，报出OOM异常，也不会回收这些来解决==内存不足==的问题。

   **软引用** ： 理解为生活中**可有可无**的生活品 。  如果内存足够，就不会回收； 当堆内存的不足时，就会回收这些对象。当没有被回收的时候，程序就可以一直使用。

   **弱引用** ：与软引用不同的是，弱引用具有更短的生命周期。当GC扫描内存区域，不管内存够不够，发现弱引用就会==直接回收==。

   **虚引用** ： 形同虚设 。 



6. > **判断是废弃常量**

   假如常量池中存在“abc“，如果当前没有对象运用该字符串的话，说明是废弃常量。



7. >  **GC回收算法**

   对用范围  ：  ==堆 和 方法区==

   - ==引用计数法== ：对象添加引用计数，基本不用

   - ==复制算法==

     - 无内存碎片，但是浪费空间

   - ==标记-清除法==

     - ==扫描对象==，对活的对象标记，==清除==未标记对象
     - 优点 ： 不需要多余空间
     - 缺点：  产生==内存碎片==

   - ==标记 压缩== 算法

     - 在清除的基础上，再次扫描，使活的对象往一端移动，多了移动的成本

     - 防止内存碎片产生

       

     **垃圾回收器**

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200907103846973.png" alt="image-20200907103846973" style="zoom:50%;" />



8. > **类加载过程**

   加载  连接（验证、准备、解析） 初始化   使用  卸载

   - 加载：

     通过==全限定类名==获得二进制字节流，并存储到==方法区==中，生成==class==对象

     <img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png" alt="img" style="zoom: 33%;" />

     类加载器 ： BootStrapClassLoader   ExtClassLoader  AppClassLoader

    通过类加载器加载，这里的==**双亲委派机制**==：

   ​    收到类加载请求时，==先判断是否被加载==，加载过直接返回。加载的时候会==委托==自己的==父类加载器==去加载，最终达到启动类加载器==BootStrap==，当父类加载器无法加载时，自己才会处理。若处理不了，会ClassNotFound 

   **好处**： 避免**重复加载**；确保加载的类**==全局唯一==**；当有多个相同限定名的类。只会加载一个

   

   - 验证 ： 验证是否符合class文件规范，不会危害JVM的安全
   - 准备 ： 为==静态变量==分配内存空间，并设置初始值int= 0 ， string = null （对象还没有产生，不包括实例变量）  ==初始化后==，赋值
   - 解析：  将常量池中的符号引用转化为==直接引用==
   - 初始化 ： （==先父后子==）才真正开始执行类中定义的 Java 程序代码，此阶段是执行 `<clinit>()` 方法的 



9. > ## **==创建对象过程内存分析==**

   1. (**静态变量、静态初始化块、常量**) > (**普通变量、初始化块**) > 构造器

   2. 子类继承父类

      <img src="I:\KSDownload\javaa.png" style="zoom:80%;" />

   3. 先父类后子类

```java
public class Person{
    int age;
    String name;
    public void walk(){
        sout("我在跑步。。")
    }
}

public class Test{
    psvm{
        Person person=new Person();
        person.name = "aaaa";
        person.age = 18;
        person.walk();
    }
}
```

> 创建对象的过程：
>
> - JVM先加载类，**双亲委派机制**（加载过就直接用，没有就双亲）。先**加载静态变量、静态方法、常量（“aaaa”）**到**==方法区==**中
> - JVM进入main方法中，首先看到 Person person=new Person();  那就**加载Person这个类**，同上，加载静态变量、静态方法、常量（“我在跑步”）到**方法区**；
> - person这个局部变量，加载到**==栈==**中，是引用对象
> - 接下来是New Person（）；在**==堆==**中分配空间，初始化属性，name =null , age = 0  ,walk()
> - JVM看到“=“，就把new Person （）的地址告诉person引用变量
> - JVM看到person.name = "aaaa"; name 指向**方法区的常量池** “aaaa"    person.age = 18;   基本类型直接赋值18
> - JVM看到walk方法，通过地址指向**方法区**中的类信息方法
> - 至此，完成步骤。

10. >  **OOM 解决 ？**

    1. 尝试扩大内存看结果
    2. 分析内存，看看哪个地方出问题
       - 能够看到哪行代码出问题 ： ==内存快照分析工具== ： MAT  Jprofiler
       - Debug,  看代码

    **MAT  Jprofiler作用 ：**

    - 分析**Dump内存文件**，快速定位**内存泄漏**
      - ==导出Dump文件== ： **-Xms1m  -Xmx8m -XX:+==HeapOnOutOfMemoryError== **      Heap + On + 错误类型
    - 获取堆中的数据
    - 获得大的对象那个



11. > **进程间的通信？**

    管道 消息队列  信号量  共享内存(**最快**) ： 直接在进程的虚拟空间进行操作

12. >  **多线程会造成的问题？**

    线程不安全；原子性  可见性  有序性 

13. > **java类在什么时候加载类？**

    new 实例化对象的时候；子类加载时，父类跟着加载 ；静态变量，代码块等用到某个类



## 设计模式

- 单例模式  :  **全局唯一**

饿汉式 :  一开始就加载

```java
public class Hungry{   // 浪费空间
    private Hungry{};
    private static Hungry HUNGRY = new Hungry();
    
    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```

懒汉式 ： 需要的时候在创建

```java
public class Hungry{
    private Hungry{};
    private static Hungry hungry ;
    
    public static synchronized Hungry getInstance(){
        if(hungry == null){
            hungry = new Hungry();
        }
        return hungry;
    }
}
```

DCL 双重检验锁的 单例模式

```java
public class Singleton{
    private Singleton{} ;  
    private volatile static Singleton singleton ;   // 保持可见性
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton ;
    }
}
```

静态内部类

```java
public class Singleton{
    private static class SingletonHolder{
        private final static Singleton INSTANCE = new Singleton();
        }
     private Singleton(){};
     public static Singleton getInstance(){
            return SingletonHolder.INSTANCE;
    }
}
```

- 工厂模式  :  在==不同条件下==创建不同的实例

  ```java
  
  ```

  





# Spring整理

项目知识整理：Spring

1. >  **Spring的 IOC  和  AOP**

   Spring的组成 ： 

<img src="C:\Users\wangsw\Desktop\File\图片\ppt\spring.png" style="zoom: 67%;" />



**IOC(==控制反转==)  ：**  一种设计思想，将原来的手动创建对象，交给==Spring==来管理、装配 ，而程序本身==被动==的接受对象  。 不需要关心对象怎么 创建的，拿来直接用。

==好处==  ：  集中管理，降低类与类之间的耦合度。

**依赖注入（DI）** :   是实现IOC的一种方法

**依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:当==某个角色==(可能是一个Java实例，调用者)需要==另一个角色==(另一个Java实例，被调用者)的==协助时==，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在==Spring里==，创建被调用者的工作不再由调用者来完成，因此称为控制反转;==创建==被调用者 ==实例==的工作通常由==Spring容器来完成==，然后==注入调用者==，因此也称为依赖注入。**



DI 的==三种==方法  ：   通过==反射==方式实现注入的，在程序的运行期间动态生成对象、执行方法和改变对象														                                                                                             属性

1. 利用Set方法注入  

   - 依赖： bean的创建依赖于Spring容器
   - 注入： bean对象中的==属性==，有容器来注入

   <img src="C:\Users\wangsw\Desktop\File\图片\ppt\2020-07-09_105851.png" style="zoom: 67%;" />

2. 构造器注入   利用`constructor-arg` 注入

   1. 利用index下标赋值

      ```xml
      <!-- 第一种 下标赋值  -->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg index="0" value="wsw"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

   2. 利用参数类型赋值

      ```xml
      <!-- 第二种 使用参数类型赋值 ，不建议使用-->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg type="java.lang.String" value="sss"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

   3. 直接使用参数名**(掌握name赋值就够了)**

      ```xml
      <!-- 第三种 使用参数参数名-->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg name="name" value="sss"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

3. 接口注入  

```reStructuredText
IOC : 控制反转，是一种设计思想。所有对象都由Spring来创建并管理。IOC容器是Spring用来实现IOC的载体。由容器通过xml、注解来帮我们配置类与类之间的依赖关系，注入依赖对象，程序是被动的接受对象，不需要关心对象是怎么创建的，拿来用即可。注入程序所依赖的对象是通过依赖注入（DI)实现。 
举个例子 ： 当对象A需要依赖对象B共同完成一项任务，之前需要手动new对象，主动创建，A与B就形成了一种依赖关系。现在由Spring来创建管理对象，需要用的时候，spring就会帮我们注入到A中，拿来用即可。依赖注入是通过反射来实现的，在程序的运行期间动态生成对象、执行对象方法。
```



2. > **Spring Bean的生命周期**

   周期的四个阶段 :   ==实例化   属性赋值   初始化   销毁==

   扩展点 ： 两个重要的接口      InstantiationAwareBeanPostProcessor作用于==实例化==阶段的前后，BeanPostProcessor作用于==初始化==阶段的前后

   <img src="https://upload-images.jianshu.io/upload_images/4558491-dc3eebbd1d6c65f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/823/format/webp" alt="img" style="zoom: 50%;" />

   

第二大类 ： Aware类型的接口 和 生命周期接口

- 无所不知的Aware    

  Aware之前的名字就是可以拿到什么资源 ，例如`BeanNameAware`可以拿到BeanName

  `BeanClassLoaderAware`    传入classLoader对象的实例

- 所有的==Aware==都是在==初始化==之前调用的

https://www.cnblogs.com/javazhiyin/p/10905294.html

```xml
1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后将值注入到Bean的属性中
			检查 Aware 接口 
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
		//	BeanPostProcess 前处理			开始 初始化 
6. 实现了BeanPostProcessor接口，Spring调用他们的postProcessBeforeInitialization()方法。		
		//	检查 InitializingBean 接口   
7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
		//	BeanPostProces后处理
8. 进行后处理，Spring调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。
```

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200908091510728.png" alt="image-20200908091510728" style="zoom: 67%;" />

3. > **Spring注解  @Autowore  和@Resource的 区别**

   共同点 ：  都可以写在字段 和 setter方法上

   不同点 ： 

   - ​	 `@Autowire`    是按照类型  ==ByType==  自动注入的，默认情况下 依赖的对象必须存在。要允许	==null==值，可以设置它的r==equired属性为false==       如果需要按照name 装配   ，结合`@Qualifier`使用		
   - `@Resource`   默认按照  ByName 装配   。 有两个属性 ， name  和  type ，将name解析为bean的名称，type解析为 bean的类型。  指定name名，就使用  ByName  ， 指定Type属性，就用 ByType 注入

   

4. > **SpringBean的 作用域**

   ![](C:\Users\wangsw\Desktop\File\图片\ppt\2020-07-09_163934.png)

   默认使用单例的，唯一的实例

   prototype（原型模式） ： 每次get 都会创建新的bean 实例

   request  ：  每次 http 请求都会创建新的bean  ，仅在当前 requset内有效

   session ：  每次 http 请求都会创建新的bean  ，仅在当前 session内有效



5. > **Spring的自动装配** 

   ByName  ：  按照Bean的 名字， 即 Bean 的  id

   ByType  ：  按照Bean 的类型  ，  即Bean 的 class



6. > **Spring的注解有哪些？**

   一般使用`@Autoware`   默认按照类型注解来装配bean 

   `@Resource`  默认通过 name装配bean

   `@Bean`     作用在方法上

   `@Compoent`   放在==类==上  ，说明被Spring管理了。如果一个bean不知道属于哪一层，用这个标记

   - ​	衍生的注解，对应MVC三层架构
   - Controller 【@Controller】  用户接受请求并返回数据
   - Dao  【@Repository】   数据库操作
   - Serivce【@Service】   服务层  涉及复杂的逻辑



7. > **Spring中BeanFactory 和ApplicationContext的区别？**

   - BeanFactory 是 古老的 factory，是最底层的接口，创建和管理bean。 ApplicationContext 是他的子类，对其功能进行了扩展。  包括 ==继承 MessageSource ，支持国际化      统一资源访问方式  同时加载多个文件  不同层次的context的实现==
   - BeanFactory 是==延迟加载==来注入bean ， 只有在使用的时候，才对Bean实例化。 这样导致不能一开始发现存在的问题。加载的时候才会发现问题。==节约内存，速度慢==
   - ApplicationContext  是容器启动的时候就==一次性创建==所有的bean，如果有错误可以一开始发现。预加载单例的Bean，需要用的时候直接拿来即可。   预先加载，浪费内存空间。
   - 一般使用ApplicationContext ，功能更强大。



8. > **==A  O   P==**

   - https://www.cnblogs.com/zhuifeng523/p/11552187.html

   - 面向==切面==编程 ，作为面向对象的补充，==将那些与业务无关的，却为业务模块所共同调用的逻辑或责任封装起来，减少代码的重复，降低模块的耦合度，有利于可扩展和可维护性==。 不修改代码的情况下，实现功能的增强

   - **应用场景** ：  

     ```xml
     记录日志 
     权限
     缓存 
     事务管理 （调用方法前开启事务，方法后，提交事务）
     监控记录跟踪
     性能优化
     异常错误处理
     同步   。。。。
     ```

     https://blog.csdn.net/u010452388/article/details/80868392

     AOP的原理 : ==动态代理==

     - JDK动态代理 ：  基于接口的动态代理
     - cglib动态代理 ： 基于类的代理

     两者的==区别== ： 

     JDK ： 只能对==实现接口的类==生成代理，不能针对类。通过==反射==生成。

     Cglib: 针对类实现代理，通过继承的方式，主要是对指定的类==生成一个子类==，覆盖其中的方法（==继承==）。由于生成子类，不能对声明为==final==的类进行代理。  通过==字节码技术==，==效率比JDK高==。

     ```java
     Spring在选择用JDK还是CGLiB的依据：
     
     (1)当Bean实现接口时，Spring就会用JDK的动态代理
     
     (2)当Bean没有实现接口时，Spring使用CGlib是实现
     
     (3)可以强制使用CGlib（在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）
     ```

     两种==动态代理==怎么实现的？

     ==JDK  ：==  

     ```java
     //-------------------
     public interface Rent {
         public void rent();
     }
     
     public class Host implements Rent {  // 真实角色
         @Override
         public void rent() {
             System.out.println("Host要出租房子！");
         }
     }
     // 用这个类，自动生成代理类
     public class ProxyInvocationHandler implements InvocationHandler {
     
         private Object target;   // 这个就是接口
     
         public void setTarget(Object target) {
             this.target = target;
         }
     
         //生成代理类  param(ClassLoder,interface,InvocationHandler)
         // 由于本身实现了InvocationHandler接口，传入this本身即可
         public Object getProxy(){
             return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
         }
     
         // 处理代理实例并返回结果
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
             // 动态代理的实质，就是使用反射机制实现
             Object result = method.invoke(target, args);  //调用接口的方法
             return result;
         }
         //--------------------------------------
         public void Seehouse(){
             System.out.println("看房子");
         }
         public void Fare(){
             System.out.println("收房租");
         }
     }
     //----------------------------------------测试
     public class Client {
         public static void main(String[] args) {
             //真实角色
             Host host = new Host();
             //代理角色   目前没有
             ProxyInvocationHandler pih = new ProxyInvocationHandler();
             pih.setTarget(host);
             // Proxy就是动态生成的代理
             Rent proxy = (Rent) pih.getProxy();
             proxy.rent();
         }
     }
     
     ```

     1. 定义一个类，实现`InvocationHandler` 接口

     2. 获得代理对象，通过 `Proxy.newProxyInstance`  

        三个参数是  ：  param( `ClassLoder, interface, InvocationHandler`)

        ​						<u>**指定的ClassLoader ; 要实现的接口 ； 传递进来的处理者。来生成真正的代理类**</u>

     3. 重写==invoke==方法，调用

      

     ==Cglib 代理==： 采用继承的方式，生成目标类的子类

     ```java
     public class CglibProxy implements MethodInterceptor {
     	// 获取代理对象
         public <T> T getProxy(Class<T> clazz) {
                       两个参数 ：  被代理的class ， 回调函数  就是 MethodInterceptor
             return (T) Enhancer.create(clazz, this);
         }
     
         @Override
         public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
             before();
             Object result = methodProxy.invokeSuper(o, objects);
             after();
             return result;
         }
     
         private void before() {
             System.out.println("cglib proxy before ...");
         }
     
         private void after() {
             System.out.println("cglib proxy after ...");
         }
     }
     //----------------------------------------测试
     public class Client {
         public static void main(String[] args) {
             //真实角色
             Host host2 = new Host2();  // 类，不实现接口
             //代理角色   目前没有
             new MethodInterceptor();
             // Proxy就是动态生成的代理
             Host2 proxy = (Host2) pih.getProxy(host2.getClass());
             proxy.rent();
         }
     }
     
     ```

     1. 定义代理类实现  `MethodInterceptor`接口
     2. 获得代理对象  ， 通过`Enhancer.create(class,methodInterceptor)`  传入要代理的对象的class
     3. 重写 `intercept` 方法，调用==invokeSuper==；

     
  
   
9. > **AOP中的连接点(Joinpoint)、切点(Pointcut)、通知(Advice)、切面(AOP)**
   
   Joinpioint :  执行过程中的明确点，一般是方法的调用
   
   切点 ： 切点表达式，定位类
   
   Advice ： 在切入点执行的增强处理。 before  after   afterReturning    afterThrowing    aroud
   
   
   
   五种通知 ： 
   
      1. 前置通知 ： 在方法执行之前（@==Before==）
      2. 后置通知：  方法执行之后  （@==After==）
      3. 返回通知： 目标方法正常返回值后（@==AfterReturning==）
      4. 异常通知： 方法出现异常之后（@==AfterThrowing==）
   5. 环绕通知： 动态代理，需要手动执行 joinPoint.==proceed==方法，相当于前四种的结合体
   
   
   
   > **SpringAOP 和 AspectJ Aop有什么区别？**
   
   ​	Spring AOP 是运行时增强 ， 而AspectJ 是编译时增强，  Spring是基于动态代理，而AspectJ 基于字节码操作的。AspectJ 相比于AOP功能更强大，SpringAOP相对更简单。
   
   
   
10. > **Spring支持的事务管理类型有哪些？**
   
    - 事务的四个特性 ==ACID  原子性  一致性  隔离性  持久性==
   
 - 声明式事务   :  利用==AOP==来切入事务
   
   - 编程式事务   : 在代码中显示调用开启事务。提交。回滚，不推荐
   
   事务的父接口是 `PlatformTransactionManager`，定义了三种方法，他的实现类必须实现开启事务、提交事务、回滚事务
   
   事务的隔离级别 ： 若干个并发事务的隔离程度
   
   -  默认的隔离级别  TransactionDefinition.ISOLATION_READ_COMMITTED   
   
​							==一个事务只能读取另一个事务提交的数据==
   
​	事务的传播特性 ：`REQUIRED`  Spring  默认的      
   
​	指的是  ==如果上下文已经存在了一个事务，有选择的指定一个事务的执行行为==
   
   ​				==required  :  当前事务就加入他，没有就新创建一个事务==、



## SpringMvc

Springmv围绕==DispatcherServlet==设计的，作用就是把请求分发到不同的处理器



1. > **SpringMvc的处理步骤**

   > 1. **根据用户请求的控制器（/hello），首先经过==DispatchServlet==**
   > 2. **由DispatchServlet调用handlerMapping处理器映射**
   > 3. **根据hello查找处理器，主要由==HandlerExecutiuon==来查找，找到==Handler==传递给DispatchServlet** 

   > 4.  **==HandlerAdapter==表示处理器适配器，按照特定的规则去执行Handler**
   > 5.  **Handler让具体的==Controller==执行，就是需要执行的代码**
   > 6.  **Controller将具体的==ModelAndView==(数据和视图)返回给HandlerAdapter**
   > 7.  **HandlerAdapter将结果给DispatchServlet**

   > 8. **DispatchServlet调用视图解析器==Viewresolver**==
   >    1. **获取了ModelAndView的数据**
   >    2. **解析视图的名字**
   >    3. **拼接视图名字，找到对应的/web-inf/jsp/&.jsp**
   >    4. **将视图渲染到视图上**
   > 9. **DispatchServlet根据视图解析器的结果，调用==具体的视图==**
   > 10. **最终将==视图呈现==给用户**

![image-20200806223146363](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200806223146363.png)



2. > **RestController  和 Controller   的区别？**

   - 单独使用Controller 只返回一个视图
   - RestController 是Controller 和 responseBody 的结合 ，返回json 或者 xml形式的数据



3. > **Spring框架的设计模式？**   ==之后解决==



## Mybatis

> **什么是Mybatis**

Mybatis是个ORM半自动框架，对JDBC进行封装，用XML文件或者注解配置原生信息。



1. > **#{} 和 ${} 的区别是什么？**

   ==${}== 是 Properties文件红的==变量占位符==，静态文本替换，比如在Properties中定义了driver ，在配置文件中使用$会被替换为 com.mysql.jdbc.driver

   ==#{}== 是sql中的占位符，Mybatis会将 #{} 替换为 ？ ；sql在执行前会根据？设置参数值，其取值方式是使用反射从对象中获取参数的值。



2. > **XML 映射文件中，除了 常见的增删改查标签之外，还有什么？**

   ```xm
   <resultMap> <parameterMap> <sql>  <include>
   sql的动态标签   <trim> <where> <set> <foreach> <if> <when>
   ```



3. > **通常⼀个 Xml 映射⽂件，都会写⼀个 Dao 接⼝与之对应，请问，这个 Dao 接⼝的⼯作原理是什么？Dao 接⼝⾥的⽅法，参数不同时，⽅法能重载吗？**

   Dao接口，就是说的Mapper接口，就是==namespace==的值。==全限名==

   ```xml
   <mapper namespace="com.nuaa.dao.***Dao">
   ```

   接口的==方法==名，就是映射文件中==MapperStatement==的==id==值。接口方法内的参数，就是传递给sql的参数。Maper接口是没有实现类，当调用接口方法，根据 ==全限名 + 方法名==拼接字符串作为key值，可以定位一个唯一的==Mapperstatement==。每CRUD标签都会解析成一个==MappertStatement==对象。

   Dao接口的方法，不能重载。因为是 ==全限名 + 方法名==  查找。

   Dao接口的工作原理 JDK ==动态代理==，为Dao接口生成代理对象，代理对象拦截接口方法，执行sql将结果返回。



4. > **Mybatis 和 Hibreanate 有哪些不同** ？

   Mybatis ==不是==一个完全的ORM框架，因为 Mybatis 需要程序员自己编写sql语句

   sql灵活 ， 但无法做到数据库无关性，如果需要支持多种数据库，需要些多套sql语句

   Hiberanate 对象/关系映射能力强，数据库无关性好，可以节省很多代码。



5. > **Mybatis 中一级缓存与二级缓存的区别**

   避免频繁操作数据库，将查询的数据放入缓存中，下次直接从缓存中读取。

   默认开启一级缓存，在操作数据库时构造sqlSession对象，对象中存储数据。不同的sqlsession的缓存区域互相==不影响==，相互之间==不能读取==。

   当进行增删改的操作时，会==清空缓存==。防止出现脏读。

   - Spring整合Mybatis时，在==未开启事务==的情况下，每次查询，都会关闭旧的sqlSession，创建新的，也就是一级缓存没有意义了。
   - 在==开启事务==的情况下，spring使用ThreadLocal 获取当前的资源的同一个SqlSession，一级缓存有效。



6. > **当实体类中的属性名和表中的字段名不一样 ，怎么办 ？**

   - 在sql语句中定义字段的别名
   - 通过<resultMap>来映射字段名和实体类名



7. > **ResultType  和  ResultMap 的区别**

   基本映射(==resultType==)  ： 使用resultType进行映射输出时，查询的列名要和pojo中的属性名一致才能映射成功

   高级映射(==resultMap==) :查询的列名和pojo 的属性名==不一致==，通过定义一个resultMap对列名和属性名做==映射==。



## Shiro

> **什么是shiro？**

Shiro是一个简单安全框架。可以帮助我们完成 ： ==认证 授权 加密 会话管理  与Web集成   缓存==等。

三个核心概念 ： ==Subject   Security   Realms==





1. > **Shiro的Subject 、SecurityManager 、Realm**

   - Subject  :  主体 ，代表当前“==用户==”，指的是与当前应用交互的任何东西都是Subject

     所有的Subject 都绑定到SecurityManager ；SecurityManager才是实际的执行者 。 

   - SecurityManager : ==安全管理器==； 所有与安全相关的操作都会SecurityManager 交互；且管理着所有的subject

   - Realm ： 域 ； shiro从Realm 获取安全数据(角色、权限等)；即 SecurityManager要验证用户身份，那么他需要从Realm中获取相应的信息比较用户是否合法；验证角色的权限。 可以把Realm看成DataSource数据源



2. > **Shiro的核心组件**

   ​	Authenticator: 管理登陆登出；==核查用户==
   ​	Autorizer:==授权==器赋予主体有那些权限
   ​	session Manager：shiro自己实现session管理器
   ​	session DAO：提供了session的增删改插
   ​	Cache Manager：缓冲管理器
   ​	Raelms：和数据库交互的桥梁



3. > **Shiro认证的过程**

   - 调用 Subject .login 方法，传递身份和凭证；然后委托给 SecurityManager，SecurityManager委托给Authenticator 进行身份验证
   - Authenticator 进行身份验证，把相应的登陆token传入Realm获取验证信息。
   - 认证策略 ：  FirstSuccessfulStrategy  AtLeastOneSuccessfulStrategy   AllSuccessfulStrategy
     - 只要一个Realm成功，只返回第一个，其他忽略
     - 只要一个成功即可，返回所有Realm验证成功的信息  （ ==默认==）
     - 全部验证通过才返回信息，否则失败



4. > **Shiro 授权的过程**

   - 调用 Sunject.isPermitted / hasRole ， 委托给SecurityManager，==SecurityManager==委托给Autorizer 进行授权
   - 在授权之前，会调用相应的Realm获取角色的权限
   - 比较是否和传入的权限匹配，如果右多个Realm，会进行循环判断，匹配则返回true，否则返回false。

5. > **注解**

   > **@RequiresRoles(value = { “admin”, “user” }, logical = Logical.AND)** : 表示当前 Subject 需要角色 admin和user
   > **@RequiresPermissions(value = { “user:a”, “user:b” }, logical = Logical.OR)** : 表示当前 Subject 需要权限 user:a 或 user:b

在项目过程中碰到的难题 ：

-    SpringMVC 传递前端数据时，乱码的问题；

-    Multipart/ form-data数据，后端接受不到

-    Spring 整合 Mybatis 一级缓存失效问题，缓存失效问题。

  ​	Srping使用SqlSessionTemplate 来 管理SqlSession ，而Template 通过反向代理Proxy来生成一个代理类； 会调用

  ​     SqlSessionInterceptor的invoke()方法 ， 包装了 sqlsession的创建。提交。销毁。每次用的不是同一个session，缓存失

  ​    效了 。





# 数据结构

 队列  Queue   先进先出     Deque 双端队列   需要了解方法

 链表

 二叉树





# 计算机网络

1. > **OSI七层协议 和 五层协议体系结构**

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200818213707819.png" alt="image-20200818213707819" style="zoom:50%;" />

   从上到下解释各层的作用

   **应用层** ： 通过应用进程间的交互来完成特定网络应用。应用层协议定义的是进程（进程主机中==正在运行的程序== ）间的通信和交互的规则。  协议有很多 ： ==域名服务DNS   HTTP协议  SMTP协议==

   **运输层**： 主要任务:  负责 两个进程之间的**通信**  提供通用 的==数据传输服务==， `传输应用层报文`

   运输层主要两种协议 ：

   - ​	TCP   传输控制协议   --- 提供**面向连接**的 ， **==可靠的==**数据传输协议
   - ​    UDP   用户数据协议  ---  提供**无连接** ，尽最大努力的数据传输服务（==不保证==数据传输的==可靠性==）

   **网络层** ： 两个计算机通信时，可能会经过很多个数据链路，也可能会经过很多个通信子网。 任务就是 ：

   ​				选择合适的网间路由和交换节点，确保==**数据及时的传输**==        使用 ==**IP协议**==

   **数据链路层** ： 简称链路层。  两台主机间的数据传输 ，总是在链路上传送的，需要专门的链路层的协议。

   在两个相邻的节点传输数据时，数据链路层将网络层的**==IP数据报==**组装成==帧== 。 在两个相邻节点间的链路上传送帧。==每一帧==包括数据和必要的==控制信息==。 通过控制协议将差错的物理信道变为无差错的、可靠传输的数据链路

   **物理层** ：  利用传输介质为数据链路层提供==物理连接==，实现比特流的透明传输，尽量屏蔽具体传输介质和物理设备的差距。

   

2. >  **TCP 三次握手  四次挥手  （ ==面试高频==)**

   -  三次握手    目的  ： 为了建立==可靠的==通信信道，准确无误的把数据送到目标处。最主要的就是==双方确认自己与对方的发送与接收是正常==

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200819183257810.png" alt="image-20200819183257810" style="zoom: 50%;" />

客户端--发送带有 ==SYN== 标志的数据包  第==**一**==次握手  --- 服务端

服务端--发送带有 ==SYN / ACK== 标志的数据包  第==**二**==次握手  --- 客户端

客户端--发送带有 ==ACK== 标志的数据包  第==**三**==次握手  --- 服务端

第一次握手 ： Client 什么也不能确认 ，Server确认了对方发送正常，自己接收正常

第二次握手 ： Client确认了： ==自己==发送，接收正常，==对方==发送正常。接收正常。 Server ： 对方正常，自己接收正常。

第三次握手 ： Client  和  Server 都确认 对方发送正常，接收正常。自己接收正常，发送正常。 



- 为什么要传回SYN?

  接收端==传回==发送端所发送的==SYN==是为了告诉发送端，我==接收到的信息确实就是你发送的信号==。

- 传了SYN，为什么还要传ACK？

  双方通信必须确认两者发送的信息都无误。SYN证明==传送方的通道==没问题，但是==接收方到传送方的通道==还需要==ACK==信号来确认



3. > **四次挥手**

   断开TCP连接 ： 需要四次挥手



<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200821091444262.png" alt="image-20200821091444262" style="zoom:50%;" />



- 客户端-- 发送一个FIN，用来关闭客户端到服务端的数据传送
- 服务端--收到FIN，并且发送一个ACK，表明收到客户端的请求
- 如果服务端没有数据要传输，想要断开连接，和第一次挥手一样，发送FIN报文，释放连接
- 客户端接受到FIN之后，发送ACK作为应答，服务端接受到后，关闭TCP连接。



​		==为什么==要进行四次挥手？

- 任何一方在数据结束之后，发出连接释放的通知，待对方确认之后进入半关闭状态。当对方也没有数据传输之后，则发出释放连接的通知，对方确认后关闭连接。



4. > **TCP、UDP的区别？**    视频电话是==UDP==协议，要求传输效率高！！

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200821093923363.png" alt="image-20200821093923363" style="zoom: 67%;" />

   UDP在传输是==**不需要**==先建立连接，对方收到UDP报文之后，不需要给出任何确认。虽然提供不可靠连接，用于及时通讯。

   （QQ语音、视频等）

   TCP： 面向连接的、可靠的传输服务，先建立连接，数据传输结束后，释放连接。（文件传输、传送、接受邮件等）



5. > **TCP如何提供可靠的连接？**

   1. 数据被==分割==成合适发送的==数据==块
   2. TCP对每一个包进行==编号==，接收方将数据包进行==排序==，把数据传给应用层
   3. **校验和** ： TCP保持它首部和数据的校验和。目的是==检测数据==在传输过程中的任何==变化==。如果检验和有差错，TCP将丢弃这个报文
   4. TCP的接收端会丢弃重复的数据
   5. **流量控制** ： TCP连接的每一方都有个==固定大小的缓存空间==。接收端只接收缓存区能接纳的数据。当接受方来不及处理发送方的数据时，能提示发送方降低发送频率。 流量控制协议 ：  滑动窗口协议
   6. **拥塞控制** ： 网络拥塞时，减少数据的发送
   7. **ARQ协议** :  基本原理:  每发完一个分组就停止发送，等待对方确认。收到确认后在发下一个分组。
   8. **超时重传**： 当TCP发出一个段后，启动一个==定时器==；等到对方确认收到这个报文段。如果==不能及时收到确认==，将==**重发**==这个报文段

​	

6. > **ARQ协议**    自动重传请求

   通过使用确认和超时两个机制，在不可靠服务实现可靠的传输。 在发送方在一定时间内没有收到确认信息，通常会重新发送。

   包括 `停止等待ARQ` ； `连续ARQ`

   - **停止等待ARQ**：

     - 为了实现可靠的传输，基本原理就是每分发完一个分组数据就停止发送，==等待对方确认==(回复ACK)。过了一定时间后没有收到确认，就重新发送，直到收到确认后，发送下一个分组。
     - 若收到重复的分组就丢弃，但是也要发送确认。

     有下面三种情况：

     1. **无差错情况**

        - 接收方收到数据==并返回确认==，发送方再次发送

     2. **出现差错情况（超时重传）**

        - 超时重传：在规定时间内发送方并没有收到确认信息，就会重传前面发送的分组。(==超时计时器==)
        - 若收到重复的分组，就丢弃该分组，但是要返回确认信息。

     3. **确认丢失和确认迟到**

        1. 确认丢失 ： 确认消息在传输途中==**丢失**==。【当**A**发送M1消息，**B**收到信息并返回确认信息，但是==确认信息==在途中==丢失==导致A并没有收到。而==A并不知道==，就==重发M1==消息，B再次收到信息后采取以下措施：】

           （1） `丢弃该信息，不先上交付`  （2）  `发送确认信息`。（A能重传说明确认消息丢失了）

        2. 确认迟到： 确认消息在传输过程中==**迟到**==。**A**发送M1消息，**B**收到后发送==确认信息==。在超时时间内并没有收到确认消息，就重发M1消息，B任然收到并发送确认信息。此时A收到新的确认信息，发送下一份信息。过一会后，A收到了第一份确认信息。 处理如下 ： （1） ： `A收到重复确认，直接丢弃`  （2） `B收到重复的M1信息，直接丢弃重复的M1信息`。

           

   - **连续ARQ协议**

     能个**提高信道的==利用率==**。发送方==维持一个窗口==，位于这个窗口的分组可以连续发送，==不需要==等待对方确认。接受方一般采用连续确认，对按序到达的最后一个分组发送确认，代表到这个分组为止的所有分组都正确收到了。

     **优点**  :  信道利用率高，容易实现。

     **缺点**：不能向发送方反应所有已经接受到的信息。 【eg. 发送方发送五条信息 ，中间第三条丢失了。这时候==接受方只能对前两个信息确认==。发送方无法知道后面三个信息的下落，只能==重新发送后三个信息==。】



8. > **滑动窗口 和 流量控制**

   TCP利用==滑动窗口==实现**流量控制**。目的是为了控制发送方的发送效率，保证接收方来得及接收。

   接受方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送速率。



9. > **拥塞控制**

   **拥塞** ： 对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能变差。

   拥塞控制 ： 为了防止过多的数据注入到网络中，这样就可以是网络中的路由器不至于过载。

   是个==**全局性的过程**==，涉及到所有主机、路由器等因素。  流量控制是端到端的控制。

   - 为了进行拥塞控制，TCP发送方要维持一个==**拥塞窗口**（cwnd）==的状态变量。窗口的大小取决于网络的拥塞程度，并且动态变化。取得是发送方和接受方窗口较小的一个。

- 拥塞控制的四大算法 ： 慢开始、拥塞避免、快重传、快恢复

  - **慢开始**  ： 基本原理 ： 由于不知道网络的符合情况，先 进行探测，即==由小到大逐渐增大拥塞窗口==的数值。初始值从1开始，每经过一次，==cwnd==加倍。

  - **拥塞避免** ： 思路 --：  让拥塞窗口缓慢增大，即每经过一个往返时间，就把 ==cwnd== +1 ；

  - **快重传与快恢复(FRR)** ：能快速回复丢失的包。【没有FRR，如果数据包丢失了，TCP会使用定时器来要求传输暂停。在暂停的时间内，没有数据包发送。】  ==有了FRR==，若接收机收到了不按顺序的数据段，

    会立刻给发送端发送重复确认。若发送机收到三个重复确认，会假定数据段丢失，并立刻重发这些数据段。不会因为丢失而暂停耽搁。



10. > **在浏览中输入一个url--->  显示页面的过程**

    

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200822214453259.png" alt="image-20200822214453259" style="zoom: 50%;" />

过程 ：  先==DNS==进行域名解析，获取对应的==ip==  ； TCP: 与服务器建立==TCP连接==

​			 发送HTTP请求 ， 服务器处理请求并返回HTTP报文，浏览器解析渲染页面



11. > **状态码**

    ![image-20200826222120101](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200826222120101.png)

    

    https://blog.csdn.net/weixin_42292229/article/details/105240877?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param



12. > **HTTP长连接、短连接**

    HTTP/1.0 默认使用==短连接==。 客户端和服务端每进行一次HTTP操作，就建立一次连接。任务结束就中断连接。当客户端访问页面资源的时候，每访问一个资源，就会出现建立一次HTTP会话。

    ==长连接== ：  保持连接特性。当一个网页打开后，客户端和服务器之间的TCP连接不会断开，当客户端再次访问这个服务器时，会继续使用这个建立的连接。 但并不是永久性的，会有一个持续的时间。 实现长连接需要客户端和服务端都支持长连接。



13. > **HTTP不保存状态的协议，如何保存用户的状态**

    HTTP是无状态协议，不保存状态。  Sesssion机制的主要作用就是通过==服务端记录用户的状态==。当用户进行的一系列操作，服务端给特定的用户创建特定的Session，从而跟踪这个用户（Session是有==期限==的，过了时间，会销毁这个Session）。

    **Cookie 被禁用怎么办？**     【常用的就是利用URL重写把Session Id 直接附在URL路径的后面】



14. > **Cookie  和 Session 的区别？**

    **Cookie  和 Session 都是用来跟踪浏览器用户身份的，应用场景不太一样。**

    - **==Cookie==**   保存用户信息 ，存储在 ==**浏览器中**==（客户端中）的数据。

      > 1. **服务端接受请求之后，建立一个Session ,并发送HTTP响应给客户端 ，这其中就==包含Set-cookie头部==。该头部包含了Session-ID，即相当于用户的标识，让服务器知道这个人是谁！**
      > 2. **第二次请求的时候，如果服务器给了Session ， 就会在请求头中添加 Cookie**
      > 3. **服务器接受请求，验证信息 ， 核对成功后返回resonse给客户端**

      <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200827214720579.png" alt="image-20200827214720579" style="zoom:67%;" />

    而 Session 是把用户的信息存储在服务端的 。

    e.g  购物车行为 ，添加商品到购物车， 服务端要知道谁添加了商品。所以要给客户端分配“==**身份标识**==”，对于浏览器采用cookie保存。每次请求的时候带上session-ID 就行了。

    - ==**Token**==

      基于Token的身份验证是==无状态==的，不将用户的数据存在服务器中。

      > 1. **用户通过用户名和密码发送请求**
      > 2. **程序验证，成功后返回一个签名的token给客户端**
      > 3. **客户端每次请求带着token**
      > 4. **服务器采用过滤器验证token，成功返回请求的数据，失败返回错误信息**

    - session 存在服务器中，有着唯一识别符号session-ID ， 通常放在cookie中。服务器收到cookie解析出session-ID，知道是哪个用户

    - cookie是用户的通行证，存储在客户端

    - token也是身份令牌，==**无状态**==，用户信息加密在token中，服务器收到解析解密知道是哪个用户



15. > **URL 和URI 的 区别什么？**

    URI  ： Uniform Resource Identifier   统一资源标志符  ， 可以标识 ==唯一一个资源==

    URL ： Uniform Resource Location   统一资源定位符 ， 提供访问该资源的==地址==  ， 也是一种 URI

    URI 相当与人的身份证号 ， 唯一确定一个人 ；  

    家庭住址相当于 URL ，通过地址也能找到人，通过定位找到人。

    ==**URL 是 URI的子集**== （URI是通过某一规则标识一个资源，通过路径是规则的一中）



16. > **HTTP 和HTTPS 的区别？**

    1. 端口 ： HTTP的URI 由 http://  起始且默认使用端口为 80 ，而 HTTPS 的 url 是 "HTTPS://" ，默认端口443
    2. 安全性 和资源消耗 ： **HTTP**协议运行在TCP上 ，所有传输的内容是==明文== ，客户端和服务器端是无法验证对方的身份。而 **HTTPS**是运行在SSL/TLS上的协议，SSL/TLS运行在TCP上。所有的传输内容都经过加密。 所以 HTTP 安全性没有HTTPS高，但是HTTPS耗费更多资源。
       - 对称加密 ：  密钥只有一个 ，加密解密为同一个密码，且解密速度快。典型的有 DES、AES等
       - 非对称加密： 密钥成对出现（==公钥无法推知私钥；私钥也无法推知公钥==）。同时加密解密使用不同的密钥，相对于对称加密来说，加密速度慢。典型的有 RSA、DSA等。





# MySQL

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200828215822013.png" alt="image-20200828215822013" style="zoom:67%;" />

- **连接层** ： 连接处理、身份验证、授权。
- **服务层** ： 完成大部分核心功能 ：查询解析、分析、优化、缓存。所有的内置函数【分析器、优化器、执行器】
- **引擎层** ： 负责MySQL中数据的存储和提取。MyIASM  Innodb 等
- **存储层** ： 将数据持久化到硬盘上

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200829130548701.png" alt="image-20200829130548701" style="zoom:67%;" />

MySQL的查询流程 ： 客户端请求 --- **连接器**（验证身份，授予权限） ---- **查询缓存**（存在缓存直接返回）--

**分析器**（对SQL语句进行语法分析） ----  **优化器**（对执行的SQL优化选择最优的执行方案）---  **执行器** ---

去引擎层==获取数据==。 



数据库引擎：

**InnoDB  和 MyISAM的区别？**

> 1. **Innodb支持==事务==，MyISAM不支持事务。这是MySQL将默认数据库变为Innodb的主要原因**
> 2. **Innodb支持外键，MyISAM不支持外键；将带有外键的Inodb转化为MyISAM会失败**
> 3. **InnoDB是聚簇索引，文件数据放在主键的索引叶子节点上，并用指针连接在一起。Innodb必须有==主键==，通过主键索引==效率很高==。而辅助索引(叶子节点存放的是==KEY字段加主键值==)需要两次查询，先查询到主键，在通过主键查到数据。**
> 4. **==Innodb==最小的粒度是==行锁==；==MyISAM==最小的锁粒度是==表锁==。一个更新语句会锁住整张表，导致其他更新和查询都会被阻塞。也是 将默认引擎设置成Innodb的重要原因。**





1. > **哪个存储引擎执行 select count(*) 更快，为什么?**

   MyISAM 在磁盘上存储了表的总行数。直接调取就行了。而InnoDB每次都需要查询整个表的总数据，然后返回值。

   为什么Innodb不存表的行数？ --- 【跟innodb事务有关，由于==MVCC==的原因（==多版本并发控制==），表应该返回多少行是无法确定的】



2. > **Mysql常见的数据类型？**

   整数类型 ： int  常用 tinyInt(0-255)

   字符串 ： char (固定长度) varchar(长度可变)   text 

   浮点类型： double  float

   日期类型 ：  Date  time  DateTime

   

## 索引

3. > 索引问题 ：
   >
   > 数据库索引的原理？为什么用B+树，不用B-tree，不用二叉树
   >
   > 聚簇索引和非聚簇索引    索引策略   常见索引的方式

   什么是索引？  官方定义 --- ：能够==高效==的获取数据的==**数据结构**==。

   索引本身也很大，不可能全部存在内存中，一般以文件形式==存在磁盘==上。

   ==优点== ：提高查询的效率，降低数据库IO成本 ； 降低数据排序的成本，降低CPU的消耗

   ==缺点==： 降低更新。添加、删除的速度。 更新表的时候，不仅要保存数据，还要调整索引的信息

   ```SQl
   CREATE [UNIQUE] INDEX idexName ON TableName
   DROP INDEX[indexName] ON mytable
   SHOW INDEX FROM table_name;
   ALTER TABLE Name ADD PRIMARY KEY(colnum_list)  # 添加主键
                    ADD UNIQUE index_Name  # 唯一索引
   ```

   **主键** :  是一种特殊的唯一索引，一张表中只能有一个主键索引。唯一标识一条记录 。 【PRIMARY KEY】

   **普通索引** ： 每个索引包含单个列 ，允许该列包含重复的值。

   **唯一索引** ： 在普通索引的基础上，列不允许有重复的值。 【UNIQUE】

   **复合索引(联合索引)**  ：  在多个字段上创建索引。只要查询是使用了创建时的第一个字段，索引就会被使用。必须遵循 ==**最左前缀匹配准则**==



4. > **B+ Tree         B-Tree**

   数据读取到内存中 是 以磁盘块为单位的 。==位于同一磁盘块的数据会一次性读出来== 。

   InnoDB 引擎 中最小的磁盘管理单位 是 ==**页**==。默认是==16== KB 



​		==B-Tree== 

​		定义了一个二元组 ==[key,data]== ； key 存储的是==主键值==  ；  data ： 一条记录==除主键外的数据== 。

![image-20200830212354734](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200830212354734.png)

记录了 【17-35】的数据 ，小于 17 的数据在p1 指向的节点 ， 依次类推



​		==**B+Tree**== 

​		在B_Tree的基础上进行优化 。  B_Tree ==每个节点==都包含==数据的 key  和 data== 。每页的存储有限，data的数据量很大会导致key的数量很小。当存储量上来是会导致树的==深度较大==，==增大IO次数==；影响查询的效率。

> 几点不同 ：   **非叶子节点只存储==键值信息== ；  数据记录在叶子节点上  ；  所有叶子节点之间用链指针相连。**

![image-20200831085704800](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831085704800.png)



**B+Tree的性质** ：

1. IO的次数取决于B+树的高度 h ，假设 数据记录为 N ，每个==磁盘块==的数据项数量为m 。 则 ==h= log(m+1)N== 。m越大，h越小。 m = 磁盘大小/ 数据项的大小 ； m -- 磁盘数据项数量越大，树的高度越小。所以==索引字段要尽量的小== 。一旦把数据放在内层节点，磁盘块的数据项会大幅度下降，导致树增高 。


2. **索引的最左匹配原则(复合索引)** :  比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的。比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的==最左匹配特性==。



- 文件很大，不可能全部存在内存中，存在磁盘中
- 索引的结构要减少查找过程中的磁盘IO次数
- B/B+树利用了磁盘的预读原理，将一个节点设置成一个磁盘页的大小，每个节点只需要一次IO即可。而红黑树的节点虽然相邻，但是在物理结构上可能会差很远。需要多次的IO查找数据



> **为什么索引用==B+==树而不是B树？**
>
> **B+树只有叶子节点才存储数据，目的是为了提高区间访问的性能。B+树支持区间查找非常方便。只需要将叶子节点扫一遍即可。而虽然提高了磁盘的IO性能但是，B树得遍历元素的效率低下。**



5. > **非聚簇索引**

   **索引文件和数据文件时==分离==的**。MyISAM的数据域存放的不是数据记录，而是数据的地址。

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831154506888.png" alt="image-20200831154506888" style="zoom:67%;" />

==主索引==是指主键索引，键值==不可能重复==；辅助索引则是普通索引，键值可能重复。

通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数
据文件中通过文件指针定位了具体的数据。==辅助索引==类似。



对于InnoDB引擎 ： **主键索引和辅助索引** 

主索引非叶子节点只记录  键值信息 ； 叶子节点是数据记录 

辅助索引 ： 非叶子节点只存储辅助索引对应的==索引字段==，而叶子节点的data字段==存储主键索引==的值。

> **为什么辅助索引存储主键信息？**
>
> ==保证数据的一致性和节省空间==。  比如订单表 和用户表 。在订单表中只存放用户的ID，而不是整个用户信息。方便维护 和节省空间 。 

也就意味着 ： 需要二次查询 ，先查询出主键信息，再从主键索引中找出数据值 。  ==**回表查询**==

但不是所有的都需要==二次==查询 ， 有个**覆盖索引**  :  【需要补充】



6. > **推荐使用整形自增而不是UUID？**

   - UUID是字符串，比整形耗费更多的==空间==
   - B+是按照顺序存储的，需要比较大小。整形数据运算比字符串==快==
   - 自增的索引在磁盘里的存储是连续的，读取也是连续的。UUID是随机的，不连续的。
   - 插入更新数据的时候，整形自增会在叶子节点的末尾建立新的节点。UUID会破坏B+树的结构，为了维持特性会进行重构，消耗更多的时间！



7. > **Hash 索引** 

   通过Hash算法(除数取余法，随机数法等)，将数据信息转化为hash值，存到相应的位置 。 如果发生hash碰撞，需要在取值是进行筛选。

   【为什么不用Hash索引？】  底层是hash表，key-value 结构 ，数据存储没有任何顺序关系。需要进行全表查询。如果有大量的重复键存在，哈希索引的效率会很低 【存在hash碰撞】。



8. > **哪些情况需要创建索引 ？ 那些不需要**？

   需要 ： 主键自动创建唯一索引 ； 查询频繁的 ； 

   不需要 ： 表数据太少 ； 经常增删改的表 ；数据重复的太多 ； 频繁更新的表



<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831163912160.png" alt="image-20200831163912160" style="zoom:67%;" />

> **查询参加考试的同学（学号、姓名·······）**
>
> ==**思路：分析查询的字段来自那些表**==
>
> ==**确定使用那种查询？  7种**==
>
> ==**确定交叉点（那些数据是相同的）**==
>
> ==**判断条件 ：学生表ID = 成绩表ID**==





## MySQL 事务

> **事务ACID  隔离级别    脏读 不可重复读  幻读   MVCC**



9. > **ACID 事务的基本要素**

   - A ： 原子性  ：  事务的所有操作，要么全部完成，要么全部失败 ； 发生错误就回滚到初始状态
   - C ： 一致性 ： 事务的前后数据保证完整性
   - I ： 隔离性 ：  每个事务的执行，相互隔离，互不影响
   - D ： 持久性 ： 事务结束后，该事务所对数据库所作的更改便持久的保存在数据库之中，不会因为外界的原因导致数据丢失 。 



10. > **脏读、不可重复读、幻读**

    **脏读** ： 一个事务读取了另一个事务未提交的数据

    不可重复读： 事务A多次==**读取**==同一数据，事务B在事务A读取期间，对数据进行了更改，导致事务A读取的数据不一致   

       					(重点是==**修改**==的操作）

    **幻读** ： 事务A读取几行数据，事务B在这是插入了一些数据，随后事务A查询发现多了几行不存在的数据，跟发生幻觉一样。				    （重点是==**新增或删除**==的操作）

​       如何解决 ？ 加锁   MVCC【多版本并发控制】



11. > **事务的隔离级别**

    - READ-UNCOMMITTED(读未提交)  ： 最低级别  -- 允许读取未提交的事务的数据 ，造成 脏读 、 不可重复读 、 幻读

    - READ-COMMITED(读已提交)  ： 允许读取事务已经提交的事务 ， 可能造成 不可重复读 、 幻读

    - REPEATABLE - READ(可重复读)  ： 对同一数据的多次读取结果是一致的，可以防止脏读、不可重复读，可能会发生幻读

    - SERIALIZABLE (可串行化)  ： 最高隔离级别 ，完全服从ACID 。

      > **当然 事务隔离越严格 ，并发的副作用越小，但是代价越大。  事务的隔离实质上是事务在一定的程度上“串行化”进行，这是与“并发”是矛盾的。**

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200901153617217.png" alt="image-20200901153617217" style="zoom:67%;" />



12. > **==MVCC==  多版本并发控制**

    为了提高数据库并发性能，用更好的方式去处理==读-写冲突==，做到即使有读写冲突时，也能做到==不加锁，非阻塞并发读==

    **读数据时** ： 如何让A读到的数据是一致的 ？ **解决数据库读一致性的问题**

    1.  **加锁** ； 当有其他事务对读取的数据进行操作时，加锁，其他事务读取时需要等待，操作数据结束后，才能读取成功。
    2.  **MVCC** ； 不需要加锁 ，通过一定机制生成某个请求时间点的**数据快照**，不管事务的执行时间多长，看到的数据都是一致的；从用户看来是某个数据的不同的版本。



13. > **InoDB的MVCC 实现机制**

    简述MVCC实现的过程 ：   在每条记录的后面**保存两个隐藏的列** ： 一个保存数据的==创建时间== ， 一个保存数据的==过期时间==，这里记录的是系统的版本号 ，每开启一个事务，版本号会递增 

    1.  select 操作  ： 
        - InnoDB 只会查找==**早于（等于）当前事务版本**==的数据行 。 可以确保事务读取的行，在事务开始之前就存在了，或者是事务自身插入或者更新的数据
        - 行的删除版本号 ， 要么还未定义 ，要么版本号==**大于**==该事务的版本 ，保证数据在事务开始之前还未删除
    2.  insert操作 ： 将新插入的行保存当前的版本号为行版本号
    3.  delete操作 ：将删除的行保存当前版本号为删除版本号
    4.  update操作 是 insert  和 delete的组合 ：  将当前的版本号作为行版本号 ； delete 则保存当前版本号 为原来行 作为删除的标识 。
    5.  ==**不用加锁**==也能达到要求 ，但是需要额外的存储空间。



14. > **事务的日志**

    InnoDB使用日志来减少事务的开销 。

    因为事务修改数据和索引会映射到表空间的==随机位置==，需要很多的==随机IO==

    > - 使用日志把随机IO变为==顺序IO== ，一旦日志安全写到磁盘，事务就持久化了，即使断电也可以重放日志恢复已经提交的事务
    > - InnoDB 后台线程只能的刷新数据到数据文件。这个线程可以批量组合写入，使得数据写更==顺序==，提高效率



1. ​	使用了日志，修改数据时只需要修改其内存拷贝，再把修改行为持久在事务日志中，不需要每次都持久到	磁盘中
2. ​    事务日志持久之后，内存中修改的数据可以在后台==慢慢刷回==到磁盘中
3. ​    如果事务日志已经持久化，硬盘数据还没有修改的时候，断电后，引擎会在重启之后自动恢复这些数据



15. > **事务的隔离性是通过锁实现的，一致性、原子性、持久性是通过事务日志实现的**   如何实现的？？

    事务的日志分为   ==重做日志 (redo)==和==回滚日志(undo)==

    - **redo（重做日志）  【保证数据的原子性和==持久化==】**

      在InnoDB中，事务的日志通过重做日志和日志缓冲实现的。 事务的记录是==顺序追加==的

      事务开启时，事务的操作都会写入缓冲日志之中；在事务==提交之前==，==缓冲日志==提前==刷新磁盘==上。

      【==**日志先行**==】

      当事务==提交之后==， 将缓冲的数据慢慢刷新到磁盘上。如果此时数据库宕机，再重启之后，根据redo的日志，将数据库恢复到之前的状态。未完成的事务继续提交。

    - **undo （回滚日志） ** 【保证数据的==一致性==】

      为事务回滚服务的。 undo 记录了数据在每个操作前的状态，如果需要回滚，就根据undo日志进行回滚。 单个事务只会回滚当前事务的操作，不影响其他事务。

      ==**注意 ：**==  两种日志均是一种恢复操作 。 redo 是 恢复提交事务修改的页操作 ， undo 是回滚行记录到特定版本 。 redo 记录 的物理日志 ，记录页的修改操作 ； undo  是逻辑日志 ， 记录旧数据的行记录

==MySQL的 日志==  ： **错误日志 ； 查询日志 ； 慢查询日志 ； 二进制日志 ； 中继日志  ； 事务日志** 



## MySQL 锁机制

16. > **MySQL 锁机制**

    - 数据操作的类型分类 ：  

      ​	读锁【==共享锁==】 :   针对同一份数据 ， 多个读操作可以==同时进行==，不会相互影响

      ​	写锁【==排他锁==】 :   在写操作没有完成前，它会==阻断==其他写锁 和读锁

    - 操作的粒度分类 ：

      ​	表级锁 ： ==开销小== ，加锁快 。发生锁冲突的==概率最高== ，并发度最低。

      ​	行级锁 ： 开销==大==，加锁慢 。会出现死锁 ；发生锁冲突的概率最小，并发度高

      ​	页面锁 ： 开销和加锁时间介于表锁和行锁之间；粒度介于两者之间，并发度一般



17. >  **InnoDB 行锁** 

    实现了以下两种类型的行锁 ： 

    - ==共享锁== ： 允许一个事务去读一行 ，==阻止其他事务==获取相同数据集的排他锁
    - ==排他锁== ： 允许获得排他锁的事务更新数据，==阻止其他事==务取得相同数据集的共享读锁和排他写锁



​	乐观锁 和悲观锁 是两种并发控制的思想，用于**解决丢失更新问题**。 ： 事务A和B基于选定的值更新该执行时，由于彼此都不知																												对方的存在，会导致==更新丢失==的问题。

- ​	乐观锁 ： 假定不会发生更新冲突 ，处理数据的过程中==**不会加锁**==，只是在更新数据的时候，根据版本号或者时间戳来判断是  					否有冲突，有则处理，无则提交事务。

  > 当事务要更改数据时，会将数据的==版本==也读出来(==V1==)。当前事务对数据变动完毕==想要提交时==，再次读取该数据的版本号(==V2)==，如果 V1 =V2就提交更新，并且==版本号+==1 ；说明数据更改了。如果==不相等==，==不允许提交==更新，一般通知用户重新操作，直到成功为止 。
  >
  > ==ABA 问题== ：

- ​    悲观锁  :    假定会发生冲突，访问、处理数据==加排他锁==，在整个数据处理中锁定数据，事务提交或回滚后才释放锁。

  ​                     悲观锁是由数据库实现的。



18. > **死锁**

    死锁： 两个或多个事务在在资源上相互占用 ， 并请求对方占用的资源 ，而导致恶性循环

    **如何解决的 ？** 

    > 1. **检测死锁  ：**
    >
    >    数据库有死锁检测和死锁超时的机制，检测到死锁就返回一个错误
    >
    > 2. **死锁恢复 ：** 
    >
    >    死锁发生后，只有部分或完全回滚一个事务，才能打破死锁 。 InnoDB 目前的处理方法 ： 
    >
    >    将持有==最少的行级排他锁==的事务进行回滚。 最后只需要执行因死锁回滚的事务即可。
    >
    > 3. 死锁影响性能 ：  影响性能而不是产生严重的错误 。在高并发的系统上，多个线程等待同一个锁，导致速度变慢。
    >
    > 4. MyISAM 获取的是全部锁，不会产生死锁
    >
    > 5. InnoDB 避免死锁 ： 事务中，如果要更新数据，应==尽量申请足够级别的锁==，即排他锁。而不是先获取共享锁，更新时
    >
    >    获取排他锁。获取排它锁时，可能有其他事务获取了相同数据集的共享锁。这时可能会==造成死锁==
    >
    >    -   事务需要修改表，每个事务应该==以相同的顺序获取锁==，大大降低死锁发生的概率。



## MySQL调优



## MySQL分区分库分表

水平拆分  垂直拆分





## 主从复制

解决分库分表的数据一致性和同步问题。 ==**配主从**==









