# JVM探究

<img src="I:\KSDownload\JVM1.png" style="zoom: 80%;" />



**==栈、本地方法栈、程序计数器==**                            **没有垃圾回收**

JVM调优 ： 方法区 ，堆（大部分调堆Heap）



- **类加载器** 

  作用：加载class文件

  **==类加载步骤：==**  

   **已经加载过的不需要重新加载**
  
  - 类加载器收到类加载请求
  - 将这个请求向上委托给父类加载器去完成。（**APP（应用程序）加载器---> Ext（扩展类）加载器--->bootStrap（启动类）加载器**）直到启动类加载器
  - 启动类加载器检查是否能够加载这个类，能就使用当前加载器，否则抛出异常，通知子类加载器检查是否执行（我们写的东西一般通过Application加载器加载的）
  - 重复上述步骤
  - 都找不到就报**ClassNotFound**



## **双亲委派机制**

<img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png" alt="img" style="zoom: 50%;" />

**作用：**

1. 防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 2
2. 保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。



## 沙箱安全机制

**保证程序安全**

基本组件：

- 字节码校验器：并不是所有类文件都经过校验器：比如 核心文件 ，java.  javax.···
- 类加载器 ：  采用的机制是双亲委派机制



## Native 、方法区

```java
public native void hello();
```

凡是带了**==native==**关键字，说明java的作用范围达不到，会去调用C语言库

会进入 **本地方法栈** （native method stack)  --->  调用本地方法接口（**JNI**）: 扩展java的使用，融合不同的语言为java所用



**方法区：**

所有的线程==共享的==，构造函数和接口代码也在此定义，所有定义方法的信息都保存在该区域，**==属于共享区域==**。

**==静态变量（static)、 常量（final)、类信息（构造函数、接口定义），运行时的常量池存在方法区中，但是实例变量存在<u>堆内存</u>中，与方法区无关。==**

static  final  Class  ,  常量池



## 栈

栈：先进后出、后进先出   **桶概念** 

队列：先进先出     **管道概念**



栈内存 ： 主管程序的运行，生命周期和线程同步 。  线程结束，栈内存就释放了；对于==**栈**==**不存在垃圾回收**问题



**==栈： 8大基本类型  + 对象的引用 + 实例的方法==**

栈运行原理： 栈帧

程序在运行的方法，永远在**==顶部==**

栈满了  ： StackOverflowError



**栈 + 堆  +  方法区  ： 交互关系**



## **==创建对象过程内存分析==**

1. **(静态变量、静态初始化块、常量)>(普通变量、初始化块)> 构造器**

**静态变量和静态初始化块/变量和初始化块的==先后顺序==取决于它们在类中出现的先后顺序**

2. **子类继承父类**，

<img src="I:\KSDownload\javaa.png" style="zoom:80%;" />



1、如果存在继承关系，就先父类后子类； 

2 、如果在类内有静态变量和静态块，就先静态后非静态，最后才是构造函数； 

3 、继承关系中，必须要父类初始化完成后，才初始化子类。



例子：

```java
public class Person{
    int age;
    String name;
    public void walk(){
        sout("我在跑步。。")
    }
}

public class Test{
    psvm{
        Person person=new Person();
        person.name = "aaaa";
        person.age = 18;
        person.walk();
    }
}
```

> 创建对象的过程：
>
> - JVM先加载类，**双亲委派机制**（加载过就直接用，没有就双亲）。先**加载静态变量、静态方法、常量（“aaaa”）**到**==方法区==**中
> - JVM进入main方法中，首先看到 Person person=new Person();  那就**加载Person这个类**，同上，加载静态变量、静态方法、常量（“我在跑步”）到**方法区**；
> - person这个局部变量，加载到**==栈==**中，是引用对象
> - 接下来是New Person（）；在**==堆==**中分配空间，初始化属性，name =null , age = 0  ,walk()
> - JVM看到“=“，就把new Person （）的地址告诉person引用变量
> - JVM看到person.name = "aaaa"; name 指向**方法区的常量池** “aaaa"    person.age = 18;   基本类型直接赋值18
> - JVM看到walk方法，通过地址指向**方法区**中的类信息方法
> - 至此，完成步骤。



**创建对象的方法 ： new关键词、对象的克隆方法、对象反序列化、Class.newInstance()反射**



三种JVM :

**HotSpot(TM)**  ······





## 堆

一个JVM只有一个堆内存，内存大小可以变

堆内存分三个区：

- 新生区
- 养老区
- 永久区





**GC垃圾回收**主要在**伊甸园区**和**养老区**·····

> OOM: 堆内存满了，不够了

**怎么快速报OOM错误？**

 ```java
public static void main(){
    String a = "asdsadada";
    while(true){
        a +=a+new Random.nextInt(88888888)+new Random.nextInt(88888888);
    }
}
 ```

## **==解决OOM ： 堆内存满了==**

1. 尝试扩大内存看结果
2. 分析内存，看看哪个地方出问题
   - 能够看到哪行代码出问题 ： 内存快照分析工具 ： MAT  Jprofiler
   - Debug,  看代码

**MAT  Jprofiler作用 ：**

- 分析**Dump内存文件**，快速定位**内存泄漏**
  - ==导出Dump文件== ： **-Xms1m  -Xmx8m -XX:+HeapOnOutOfMemoryError **      Heap + On + 错误类型
- 获取堆中的数据
- 获得大的对象那个





## GC - 垃圾回收机制

**作用区域** ： ==方法区 +  堆== 

新生区（伊甸园区、幸存区form、幸存区to），幸存区，老年区

**并不是三个区域统一回收。大部分时候，回收==新生区==**

from和to区**不断交换**的，**==谁空谁是to区==**，不固定

当一个对象经过==**15次GC**==，还存活就会进入养老区！

GC种类 ： 轻GC ,重GC（全局GC）







GC常用算法 ： 

- 标记清除法
  - 扫描，标记存活的对象，清除不要的对象
  - 优点：不需要额外的空间！
  - 缺点：==两次扫描，浪费时间，产生内存碎片==
- 标记压缩法
  - 在标记清除的基础上（==防止内存碎片的产生==）进行压缩，排序，使对象往一端移动，多了移动的成本
- 复制算法（**主要用在==新生区==**）
  - 好处：没有内存的碎片
  - 坏处：永远多一块空白的to区，==浪费了内存空间==
  - 使用最佳场景 ： 对象存活率较低时
- 引用计数器  （基本不用）



新生区：

- 存活率低
- 复制算法

养老区：

- 区域大，存活率高
- **标记清除法（产生内存碎片）   +   标记压缩（碎片太多时，压缩清除一次）   混合使用**



## 新生代收集器还是老年代收集器：

- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1







