#   Java基础知识

1. > **为什么要重写equals还要重写hashcode?**

   在hashMap中，要比较两个key是否相等，自定义类的hashcode和equals是继承Object类的(**Object的hashcode是本地方法，调用的c或c++的方法返回的值**)，相同含义的两个对象code是不相等的。向hashmap中添加元素时，先判断hashcode是否相等，相等就继续判断equals方法，再相等新的value就覆盖旧value。相同对象，hashcode一定相等；hashcode相等，equals不一定等。equals方法业务逻辑比较复杂，影响效率。为提高效率，同时重写两个方法，先比较hashcode，若不等就不要比较equals了。 重写方法应满足：hashcode相等，equals应相等；若不等，hashmap中会产生链表。equals相等，hashcode应相等。
   
   ```JAVA
   1）对于==，比较的是值是否相等
   
          如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；
   
   　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址
       
   2）对于equals方法，注意：只适用引用数据类型,  比较的是是否是同一个对象
       	
   　　　　如果没有对equals方法进行重写，(Object 中的 equals 和 == 是一样的 , 比较两个地址的值是否一样)
       	则比较的是引用类型的变量所指向的对象的地址；
   
   　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
   ```
   
   
   
2. > **map的分类和其情况**

   - hashmap:  主要实现类；线程不安全，效率高；存储 **null 的key和value**      **(数组+链表+红黑树)**

   不支持线程同步，多个线程同时写数据时，会导致数据不一致。若需要同步，可以使用ConcurrentHashMap

   - Hashtable: 古老实现类；线程安全，效率低 ；**==不能存储==** null 的key和value,线程同步，导致写入速度慢

   - LinkedHashMap:  保证在遍历的时候按照添加的顺序遍历。**能够记录添加元素的先后顺序**

   - treeMap :  保证按照添加的**Key-Value**进行排序，实现排序遍历。考虑==**key的默认排序或定制排序**==

     定制排序 ： 在定义的类中实现==**Comparable接口**==，并重写CompareTo 方法   

     ​                      在TreeSet中传入new Comparator()对象



3. > **为什么有时候会出现4.0-3.6 =0.4000001这种现象**

   十进制的小数无法用二进制准确表达。计算的时候先转化为二进制进行计算，出现误差。

   十进制在内存中以**==补码==**的形式存在。



4. > **java数据类型及自动拆装箱**

   基本数据类型 ： byte   short   int   long   float  double    char(字符型) 

   - byte:  1个字节，-128-127  defeat : 0
   - short:  2个字节，-2^15 -- 2^15-1   defeat : 0
   -  int :    4个字节， -2^31-- 2^31-1   defeat : 0
   - long:    8个字节 ， -2^63 -- 2^63-1  defeat : 0L
   - float:  4个   默认值是 **0.0f**
   - double:  8个  默认值是 **0.0d**
   - char  2个字节 

​      自动拆装箱 ： 基本类型和其对象包装类型之间的转换  ， int ---> Integer   double  --> Double



5. > **什么是值传递和引用传递**

   对于基本数据类型，都是值传递。 传递的是变量的一个副本，不影响对象本身。不会改变值

   引用传递 ： 传递的是对象的地址，对参数修改会改变原参数的值。

​	

6. > **Array和ArrayList的区别**

   Array数组可以包含基本类型和引用类型，ArrayList只能包含对象类型

   数组大小固定，高效；ArrayList大小可变化，牺牲效率

   ArrayList可以算是Array的加强版 提供了新的功能 添加全部 addAll（） 删除全部 removeAll（） 返回迭代器 iteratorAll（）

   ```java
   List<String> list=Arrays.asList(array); 
   ```



7. > **&与&&的区别**

   &&是短路与，虽然都是两遍都是true,整个表达式都是true。但是&& 如果左边的表达式是false，右边会被直接短路掉



8. > **Java和javaScript的区别**

   Java是**面向对象**编程，适合应用程序开发；javaScript可以嵌入web页面运行的**基于对象**和时间驱动的编程语言。

   java开发简单的程序必须设计对象；而javaScript提供了许多丰富的内部对象给人员使用



9. > **正则表达式    java怎么支持正则表达式的**  

   查找复杂规则的字符串，正则表达式是记录文本的规则的代码，在进行字符串匹配具有强大的能力

   java中的String类提供了方法，matches()、replaceAll 、replaceFirst   spilt



10. > **==synchronized==锁修饰静态方法？修饰成员的方法？**

    - synchronize修饰 静态方法**锁住的（.class)==类==**，其他线程必须等待当前线程结束才行

    
    - 修饰成员的方法（每个实例对象都拥有成员方法，不被对象实例共享）： **其实是对==实例对象==加锁**，线程获取的是调用该方法的对象实例的锁
    
    - 修饰代码块：其作用的范围是大括号{}括起来的代码，作用的对象是**调用这个代码块的对象**



11. > **volatile关键字**

    保证有序性和可见性。vllatile变量规则：对这个变量的==写==操作先行，后面才是==读==操作 

    禁止指令重排序

    

12. > **synchronized 和 lock锁**

    synchronized是==关键字==，来修饰方法或者代码块，能够保证同一时刻只有一个线程执行改代码

    lock是一个==接口==，synchronized发生异常时，会**自动释放锁**；而lock如果没有主动通过unlock()释放锁，会造成==**死锁**==，所以会在finally中释放锁。**lock**可以让等待的**锁终止响应**，而使用synchronized时，等待的线程会**一直等待**下去。



13. > **final关键字**

    类： ==**不能被继承**== 。 类中的变量可以**根据需要**设为final,但是所有成员方法**被隐式的设为final方法**

    变量 ： 如果是基本类型，一旦初始化**==不能被更改==**；引用变量，在初始化后不能再让其指向另一个对象
    
    方法：不能被重写，可以被继承。
    
14. > **java的特性**

    **封装、继承、多态**

    **封装： 属性私有private，提供get/set方法**，外部通过getset方法访问

    **继承：extends，只用单继承，没有多继承(super)**，**<u>私有的无法继承</u>**

    ​			==final声明的类不能被继承==

    ​			继承了父类中定义的所有实例变量和方法， 并且增加了独特的元素

    **多态：子类中没有，就调用父类的；若重写了父类的方法，执行子类的方法**

    对象能执行什么方法，主要看对象**左边**的类型，和右边的关系不大

    注意！： **方法多态，不是属性多态**！ 

    方法的多态性：方法的重载和方法的重写



15. > **String 不可变？**

    ==**final**==修饰了，基本类型，一旦初始化，值不变；引用类型的变量==不能指向另一个对象==

    String类是个final类。字符串是**==安全的==**。如果可变，平常用的用户名和密码都是以字符串为变量传入的，如果改变了字符串指向对象的值造成不安全。String不可变，同一个字符串实例可以被线程共享。



16. > **类和对象的区别**

    类是对某一类事物的描述，是==抽象==的。而对象是实实在在的个体，是类的一个==实例==

    **对象是函数和变量的集合体，而类是一组具有相同属性的==对象的集合体==**



17. > **Object类的方法有哪些？**

    **Object()** : 默认构造方法   **clone()**  ： 创建并返回此对象的一个副本
    
    **equals(Object obj)**  ； **finalize()**当垃圾回收器确定不存在对该对象的更多引用时，由**对象的垃圾回收器**调用此方法
    
    **getClass()**返回一个对象的运行时类  ； **hashCode()**返回该对象的哈希码值。 **notify()**唤醒在此对象监视器上等待的单个线程。 **notifyAll()**唤醒在此对象监视器上等待的所有线程     **toString()**返回该对象的字符串表示。
    
    **wait()**导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
    
    **wait(long timeout)**导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
    
    **wait(long timeout, int nanos)** 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量



18. > **方法的重载和重写的区别**

- ==重载==（overloading)

  1. 以统一方式处理不同类型数据的一种手段 。 多个**==相同名称==**的函数同时存在，参数不同；是多态的一种表现
  2. 创建多个方法，相同的名字，具有不同的参数和不同的定义。通过传递的参数决定使用哪个方法
  3. ==方法名相同==，==参数类型和个数不一样==；返回值类型==可以相同也可以不同==；==**无法通过返回值类型区别重载函数。**==

  

  ==重写==(overriding)

  1. 父类与子类之间的==**多态性**==，对父类函数重新定义。子类中某方法与**父类具有相同的名称和参数**，可以说该方法被重写。
  2. 子类可继承父类的方法，可不必重写
  3. 若子类中与父类中的某一返方法具有相同的方法名、返回类型、参数，则原来的方法将被覆盖。



19. >  **static关键字是什么意思？java中是否可以覆盖一个private方法或者static方法**

- static关键字表示**静态**的意思，用于修饰成员变量和成员函数。表示可以在==没有类的实例的情况下被访问==。

- ==都不能==

  覆盖，也就是我们常说的重写，是子类继承父类，且子类中的方法和父类中的方法，方法名相同，参数个数和类型相同，返回值相同。

  **private**修饰的方法，==不能被继承==，所以也不存在重写（覆盖）

  **static**修饰的方法，是==静态==方法，**==静态绑定==**了，在编译时就和类名就行了绑定。而重写发生在运行时，**动态绑定**的。何况static方法，跟类的实例==**无关**==



20. > **String能被继承么？**

    String 类是不能被继承的，因为他是被==**final**==关键字修饰的

    ```java
    public final class String
        implements java.io.Serializable, Comparable<String>, CharSequence {
        /** The value is used for character storage. */
        private final char value[];
    
    ```

    String类实际是一个**char[]数组**存储数据的。而这个数组也是被==**final**==关键字修饰的

<img src="https://img-blog.csdn.net/20180906132649986?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neXViaXNob3VsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />



21. > **请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？**

    - **String**类的底层实现是 **==final char[ ] value==**，也就是说String字符串是存在一个char数据中的，static说明value是类变量，final规定了value之不可变  。   StringBuffer 和 StringBuilder 的底层都是char[ ] value数组

    - **String类**的字符串值存在常量池不可进行修改，所以认为String类是线程**==安全==**的

      **StringBuffer**类是线程==安全==的，他的方法都是**synchronized**关键字修饰的

      **StringBuilder**类是线程==不安全==的

    - String 的拼接，实际上是调用了StringBuilder.appedd()，然后调用 toString()



22. > **什么是泛型？类型通配符？ 上限，下限？** 

    **==参数化类型==**  ：  把类型当做参数来传递 ： 只能是**==引用类型==**

    List<E>     List<Integer>

    **通配符**  *<u>List<?> list</u>*    ? 代表可以**==匹配任意类型==**。但是就只能调**与对象无关**的方法了

    通配符上限： 只能操作数字类型的元素(float  Integer  Double )    **List<? extends Number> **    只能是NUmber的==子类==

    通配符下限： 比如**TreeSet<? super  E>**   : 传递进来的==只能是E的父类或E本身==

    **==准则 ：==** **上界不存，下界不取**

    ​			使用 ? extends  E     只能get  ==不能add（除null）之外的对象==

    ​			使用? super E    只能add  ==不能get==



23. > **是否在static环境中访问非static变量？**

    不可以在static环静中，不可以访问非static。因为**静态**的成员属于==类==，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，==没有实例==，**非静态变量还没有初始化**，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态！



24. > **请你谈谈如何通过反射创建对象？**

    1. 通过类class对象调用new Instance()，例如： String.class.new Instance()

    2. 通过类class对象的getConstructor()或者getDeclaredConstructor()获取构造器对象调用new Instance()

       ```java
       String.class.getConstructor(String.class).newInstance("Hello");
       ```



25. > **java是否继承多继承？**

    不允许存在多继承。

    1. 若子类继承的父类中拥有==相同的成员变量==，子类在引用该变量时将无法判别使用哪个父类的成员变量
    2. 若一个子类继承的多个父类==拥有相同方法==，同时子类并未**重写**该方法（若==重写==，则直接使用子类中该方法），那么调用该方法时将无法确定调用哪个父类的方法



26. > **接口和抽象类的区别？**

    **抽象类**是对某一类==事物的抽象==；**接口**是对某一==动作的抽象==。  

    例如 ：  男人，女人 可以设计一个高级抽象类  **人 ** 。对于接口 ： 人都要吃饭，喝水，工作等等 ，把这些动作设计成接口

    在java中，==一个类只能继承一个类（人不能是生物又是非生物）；但可以实现多个接口==，有不同动作

    1. 抽象类和接口==**不能实例化**==，若要实例化，涉及==**多态**==！
    2. 如果抽象类要实例化，抽象类定义的对象必须要==指向子类对象==，这个类继承了抽象类并且实现了抽象类的所有方法！同理，接口要实例化，接口定义的变量要指向一个子类对象，这个类实现该接口并且实现了接口的所有方法！

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2139861116,2509584885&fm=173&app=49&f=JPEG?w=500&h=290&s=CA43DF10B9DE71C84EEC555E030010F1)

3. 接口中只对方法进行声明，即所有方法都是抽象的；抽象类可以声明也可对方法进行实现（可以有抽象和非抽象方法（私有，protected。public都可以））
4. 如果子类不能实现抽象类或者接口的所有的方法，那么这个子类必须是抽象类
5. 抽象中的方法要被实现，所以方法不能是static方法，也不能是private方法
6. 当你关注事物的本质用抽象类，关注某种操作，用接口



27. > **==java的多态！！==**

    https://www.zhihu.com/question/30082151/answer/120520568

    多态的三个==前提==：

    - **有继承关系**
    - **子类重写父类的方法**
    - **父类引用指向子类对象**

    对象能执行什么方法，主要看对象**==左边==**的类型，和右边的关系不大

    ==子类中没有，就调用父类的；若重写了父类的方法，执行子类的方法==        **动态绑定**

    **多态的弊端**：<u>*多态后不能使用子类特有的属性和方法*</u>



28. > **Comparable和Comparator接口是什么？有何区别？**

    - Comparable是排序接口只包含一个**compareTo()**方法。可以给两个对象排序。

    ==实现Comparable接口的**类**支持排序==，自然排序  ， 表示这个类支持排序     所以Arrays.sort()   Collection.sort 即可按照内部排序进行

    <img src="I:\KSDownload\comparable.png" style="zoom:80%;" /> 

传入对象和当前对象进行比较大小。

- Comparator是**比较器**,    外部排序     比如在TreeMap定义一个**排序器**        这里是==升序==

  <img src="I:\KSDownload\comparator.png" style="zoom:67%;" />

比较器中有两个方法 ： 

```java
int compare(T o1, T o2);
boolean equals(Object obj);
```

可以外部调用这个比较器。

```java
Collections.sort(list, new Comparator());
```



29. > **Static Nested Class 静态内部类 和 Inner Class内部类**

    - Static Nested Class**静态内部类**可以在==不创建==实例的条件下直接创建，因为它只访问静态方法和成员，它和类直接绑定，并且不能访问任何非静态类型的方法和成员变量。(还没创建，怎么访问？)

    - Inner class内部类是和实例绑定的，他可以访问实例的成员变量和方法，所以在创建他之前必须先==创建==一个==实例==，然后通过实例创建它才行。



30. **按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个==副本==。因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的==内存地址的副本==，而不是值的副本。因此，如果函数修改了该参数的值，调用代码中的原始值也随之改变。**



31. >  **JAVA如何异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？**

    - 一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；

      try 用来指定一块预防所有“异常”的程序；

      catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；

      throw 语句用来==**明确地**==抛出一个“异常”；

      ```java
      if(a!=b)
             throw new  Exception3("自定义异常");
      }
      ```

      throws 用来==**声明**==一个成员函数可能抛出的各种“异常”；

      ```java
      void doA(int a) throws Exception1,Exception3{
      ```

      Finally 为确保一段代码不管发生什么“异常”都被执行一段代码



32. > **两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？**

    1. 对象相同即equals相等，那么哈希码一定要相同。要维护那个hashcode的常规协定
    2. 两个对象hashcode相同，equals可以不同。



33. > **说明如何通过反射获取和设置对象私有字段的值？**

    可以通过类对象的**getDeclaredField()**方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。



34. > **Query接口的list和iterate方法有什么区别**

    1. 返回的类型不一样，list返回List，iterate返回iterator
    2. 查询策略不同。获取数据的方式不一样，list会==**直接查询**==数据库，==iterate==会先到数据库中把id取出来，然后真正要遍历某个对象的时候先到==缓存中==找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为**==n+1==**
    3. iterate会查询2级缓存，list只会缓存，但不会使用缓存（除非结合查询缓存）。  
    4. list中返回的list中每个对象都是原本的对象，iterate中返回的对象是代理对象



35. >  **什么是构造函数？什么是构造函数重载？什么是复制构造函数？**

    对象一==创建==就会调用**构造函数**（**即new对象产生后**），函数名和==**类名相同**==。 对象建立，构造函数只运行==**一次**==。
    
    特点： 函数名和类名相同   无返回类型
    
    当一个类没有定义构造函数，编译器会**默认给一个无参构造器**。 隐藏不显示。
    
    **构造函数重载**：可以为一个类创建多个构造函数。<u>*每一个构造函数都必须有他唯一的参数列表*</u>
    
    java不支持像C++中那样的复制构造函数



36. > **hashcode 和 equals方法的联系。**

    1. 两个相同的对象（equalsxt）必须有相同的散列码。
    2. 散列码相同，对象不一定相同。



37. > **HashMap 和 ConCurrentHashMap 的区别？**

    hashMap 线程不同步 ，虽然处理数据效率高，但是在多线程的情况下存在安全问题。

    ConCurrentHashMap线程安全，==将map分段，每个段进行加锁==（**分段锁**），【而不是hashtable 和 synchronizedMap【**sɪŋkrənaɪzd**】整个map加锁！】   多线程访问；默认是16个线程同时访问。【读操作不加锁，由于HashEntry的value变量是 **volatile**的，也能保证读取到最新的值。】
    
    https://www.cnblogs.com/zhengbin/p/5654805.html
    
    **==volatile==** : 保证了不同线程对这个变量进行操作时的==可见性==，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 【当把变量声明为volatile类型后，编译器与运行时都会注意到这个**==变量是共享==**的，读取的时候返回的是==最新==的】
    
    - （实现可见性）禁止进行指令重排序。（实现==有序性==）
    - volatile 只能保证对单次读/写的==原子性==。



38. >  **hashMap底层实现**

    **数组+链表+红黑树**



39. > **hashMap的key是自定义的一个类，必须重写hashcode() 和 equals() 方法**



40. > **HashMap的容量为什么是2的n次幂?**

    1. 对key的hash计算效率更高。因为当length是2的n次方的时候： hash % length == hash & (length - 1)。**位运算**的效率比直接**取余**的效率会高很多。
    2.  在扩容的时候，会重新计算旧map的元素hash。(n-1)的2进制也就是01111111这样形式的，**这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上**，==**减少hash碰撞**==，避免形成链表，使效率降低。




41. > **concurrentHashMap的锁加在哪儿？**
    >
    > https://www.cnblogs.com/theRhyme/p/9404082.html#_lab2_0_0

    1.7 ：   **==Segment==数组结构和==HashEntry==数组结构组成**

     一个ConcurrentHashMap里包含一个**Segment**数组，Segment的结构和HashMap类似，是一种==数组和链表结构==，Segment数组中每个Segment里**包含（==锁住==）一个HashEntry数组**，一个HashEntry数组中的每个hashEntry对象是一个**链表的头结点**，每个链表结构中包含的元素才是Map集合中的key-value键值对

![img](https://images2018.cnblogs.com/blog/1158841/201808/1158841-20180803170529789-1723374949.png)

​		1.8 ：  **数组+链表+红黑树**

​			`transient volatile Node<K,V>[] table`;

​			注意这里的Node数组加了==**volatile**==进行修饰，table数组在内存中对所有线程都及时可见，如果一个线程修改了table数组的值，其他线程中如果自己的线程栈中有table的副本，就会把table缓存行设置为失效，**强制从主内存中读取table数组的值**。

==修改==了就直接**强制刷新到主内存中**，其他线程如果有缓存，设置为无效

- 由==synchronized==锁住transient volatile **Node**<K,V>[] table 数组的一个元素(即==**头结点**==，锁粒度比Java7低)，还通过==**CAS**==(Unsafe对象)操作数据更新、插入等



42. > **TreeMap 底层 ，红黑树原理**

    TreeMap : 可以实现自然排序和外部排序。   根据键的自然顺序排序，或者外部`new Compartor（）` 进行外部排序。

    

    红黑树 ： 自平衡的排序二叉树
    
    性能比哈希表低，哈希表无法提供键值对的有序输出，红黑树是排序插入的，可以按照键值的大小输出。
    
    1. 每个节点要么上红色，要么是黑色
    2. 根节点永远是黑色
    3. 所有的叶节点都带有两个空的==**黑色**==结点
    4. 如果一个结点是红的，则它的两个儿子都是黑的。也就是说在一条路径上==**不能**==出现相邻的两个红色结点。
    5. 从任一节点到其每个叶子的所有路径都包含**相同数目**的黑色节点。



43. > **ArrayList 的数组是否会越界？**

    对于ArrayLIst而言，实际上是对数组的操作。 虽然ArrayList会自动扩容，将老数组的元素重新拷贝到新的数组中，扩容容量为原来的**==1.5==**倍 。

    ```java
    elementData[size++] = e
    ```
    
    上述代码是list添加数据的步骤分为两步，一个是在 elementData[size]  存放数据    二是增大size的值
    
    线程不安全，线程不同步，所以多个线程同时add方法，会出现数组**==越界==**问题



44. > **为什么集合类没有实现Cloneable和Serializable接口？**

    ==克隆（cloning）或者序列化（serialization）==的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化

    - 克隆是把一个对象里面的属性值，复制给另一个对象。而不是对象引用的复制
    - 实现Serializable序列化的作用
      - 将对象的状态保存在存储媒体中一边可以在以后重写创建出完全相同的副本
      - 按值将对象从一个应用程序域法相另一个应用程序域
      - 实现Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。在网络传输中就要序列化



45. > **什么是迭代器？**

    迭代器是可以将集合中所有元素==遍历==一遍。
    
    迭代器(Iterator)是一个**对象**，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器(container)对象中的各个元素，而用不必暴露该对象内部细节的方法。

```java
public static void main(String[] args) {  
        List<String>list=new ArrayList<>();  
        list.add("a");  
        list.add("b");  
        Iterator<String>it=list.iterator();//得到lits的迭代器  
        //调用迭代器的hasNext方法，判断是否有下一个元素  
        while (it.hasNext()) {  
            //将迭代器的下标移动一位，并得到当前位置的元素值  
            System.out.println(it.next());    
        }     
    }  
```

也可利用foreach增强for循环，本质上也是迭代器

想要批量删除list中的元素： 可以使用迭代器删除

```java
Iterator<String> it = aList.iterator();
         while(it.hasNext())
         {
             if("abc".equals(it.next()))
             {
                it.remove("abc");          
             }
         }
```

46. > **快速失败(fail-fast)和安全失败(fail-safe)的区别？**  迭代器相关的问题

    - 快速失败（java.util.包下的集合都是快速失败）：当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了==**modCount**==的值)；这时，**modCount 不等于 expectedModCount（创建迭代器对象时就被赋值为 modCount）**，就会抛出==ConcurrentModificationException==异常，产生**fail-fast**事件。
    - 安全失败（java.util.concurrent包下的集合都是安全失败)： 基于安全失败的是对原数组进行拷贝，在拷贝的内容进行遍历；源数据改变不影响结果。不会



47. > **Collection、list、Set、Map、Collections是什么以及各自的特点。**





# Java高级部分



1. > **多线程中的`i++`线程安全么？**

   不安全。由于i++不是原子性操作。它分为取出i值，i+1，然后赋给原来的i，多个线程操作会出问题。

   每个线程都有自己的内存空间，每个线程对共享变量操作时，==必须先把变量从主内存中加载到自己的内存中==，等操作完成后再save到==主内存==中。

   如果一个线程运算完之后没有刷到主内存中，却被另一个线程读取，这时就是脏读了。

   - 那加上`voliate`能否解决这个问题？  

     ==不能==！ voliate只能保证可见性，并不能保证原子性！

     解决办法： 对 i++ 操作加上同步锁！同时只能有一个线程执行操作！

     或者使用支持原子类操作的类，比如： `java.util.concurrent.atomic.AtomicInteger`，使用 CAS 算法。



2. > **如何安全的实现一个计数器？**

   使用加锁。 比如 Synchronized或者lock 。 也可以使用`Concurrent`包下的原子类！



3. > **多线程的同步方法**

   - 使用同步方法    ==synchronized关键字修饰的方法==   调用方法前，需要获得内置锁，否则处于阻塞状态

     ```java
     public  synchronized void addMoney(int money){  
             count +=money;  
             System.out.println(System.currentTimeMillis()+"存进："+money);  
         }  
     
         //取钱  
     public  synchronized void subMoney(int money){  
             if(count-money < 0){  
                 System.out.println("余额不足");  
                 return;  
             }  
             count -=money;  
             System.out.println(+System.currentTimeMillis()+"取出："+money);  
         }  
     ```

   - 同步代码块    ==synchronized关键字修饰的语句块==

     ```java
     public void addMoney(int money){  
     
             synchronized (this) {  
                 count +=money;  
             }  
             System.out.println(System.currentTimeMillis()+"存进："+money);  
         }  
     ```

     注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

   - 使用特殊域变量(`voliate`)实现线程同步

     ```java
     private volatile int count = 0;// 账户余额  
     
         // 存钱  
      public void addMoney(int money) {  
     
            count += money;  
            System.out.println(System.currentTimeMillis() + "存进：" + money);  
       }  
     ```

     注：**voliate** 修饰告诉虚拟机该域可能会被其他线程更新      
     
     ​	   voliate不能保证==原子性==，因此==不能==替代synchronized ，也不能修饰final变量。
     
   - **使用重入锁实现线程不同步**    `ReentrantLock类`是可重入、互斥、实现了Lock接口的锁
   
     记得及时==释放==锁，否则会出现死锁。通常在`finally`中释放
   
     ```java
     ReenreantLock类的常用方法有：
     	ReentrantLock() ：创建一个ReentrantLock实例
     	lock() ：获得锁
     	unlock() ：释放锁
     注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。
         
         private  int count = 0;// 账户余额  
     
         //需要声明这个锁  
         private Lock lock = new ReentrantLock();  
     
         // 存钱  
         public void addMoney(int money) {  
             lock.lock();//上锁  
             try{  
             count += money;  
             System.out.println(System.currentTimeMillis() + "存进：" + money);  
     
             }finally{  
                 lock.unlock();//解锁  
             }  
         }  
     ```
   
   - 使用局部变量实现线程同步      //使用ThreadLocal类管理共享变量account
   
     如果使用==ThreadLoca==l管理变量，则每一个使用该变量的线程都获得该变量的==副本==，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响
   
   - 使用concurrent下的原子类操作   ： 
   
      `util.concurrent.atomic`包中提供了创建了原子类型变量的工具类**，



4. > **生产者，消费者模式**

   ![img](https://img-blog.csdn.net/20161101155643986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

   生产者消费者问题是线程中的经典问题： 生产者和消费者在同一时间内公用同一存储空间，生产者向空间里生产数据，消费者取走数据。

   - 优点： ==解耦== ， 有缓存区的存在，消费者和生产者不相互依赖。
   - 支持并发。 生产者往缓存区一丢，就去生产下一个数据，不用依赖消费者的处理数据的能力。处理==并发==



5. > **什么是AQS**

   队列同步器。 是java并发用来构建锁和其他组件的基础框架。 

   AQS依赖内部的==同步队列==。如果当前线程同步失败，AQS会为该线程以及等待状态信息构造一个==Node==;同时==加入同步队列==的尾部，同时阻塞该线程。当同步释放时，唤醒队列的头结点（==先进先出==）

   ```java
   private transient volatile Node head;
   private transient volatile Node tail;
   private volatile int state;
   ```

   state记录状态 ， head 和tail记录头尾节点 。  state = ==0==  --> 同步状态==可用==  state = ==1==  ，同步状态被==占用==

   - 获取同步状态

   ==state = 0== ,线程A可以顺利获得锁，后将state =1 ；在A没释放锁期间，线程B也来获取，当前==state=1==，被占用。  将B线程的信息构建一个==Node== ， 放入队里中 ，head和tail分别指向队列的头部和尾部  ，同时阻塞线程B（`LockSupport.park()`方法），如果有后续线程依次构建Node放入队列中 。 

   - 释放同步状态

   当线程A释放锁时，state = 0 ； 此时会唤醒后续节点（唤醒，就是调用`LockSupport.unpark(B)`方法）， 即B线程顺利获得锁，获取锁后，B Node顺利出队列



6. > **线程池的概念** ， 有几种

    线程池的作用 : 

   - 降低系统资源消耗，通过重用已存在的线程，降低==线程创建和销毁造成的消耗==；
   - 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；
   - 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生==OOM==，并且会造成cpu过度切换

   四种线程池： 

   1. newFixedThreadPool    创建==指定线程数量==的线程池    如果线程数量达到最大数，将加入阻塞队列

      适用于<u>线程资源有限，数据量小</u>

   2. newCachedThreadPool    创建可缓存的线程池。无限扩大的线程池，数目为Integer.Max  容易==OOM==

      若长时间没有往线程池中提交任务，即线程空闲超过时间，线程自动终止。若有任务，重新创建。

      适用于<u>负载较轻，响应时间要求高</u>

   3. newSingleThreadExecutor : ==单线程==的线程池，保证任务的顺序进行

   4. newScheduledThreadPool ： 创建==可定期或延时==执行任务的线程池



7. > **创建线程的方法**

   1. 继承Thread类

      - 自定义线程类继承==Thread类==

      - 重写==run()==方法，编写执行体

      - 创建线程对象，调用==start()==方法启动线程

      - ==**有局限性，一个对象不能被多个线程使用**==

        ```java
        public class TestThread extends Thread{
            //1:继承thread类，重写run方法，start（）启动
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println("线程"+i);
                }
            }
        
            public static void main(String[] args) {
                TestThread testThread = new TestThread();
                testThread.start();
                for (int i = 0; i < 10; i++) {
                    System.out.println("我学习线程"+i);
                }
            }
        }
        ```

   2. 实现==runnable==接口

      - ==实现Runnable接口==

      - 重写==run()==方法，编写执行体

      - 创建线程对象，调用==start()==方法启动线程

      - **==推荐使用，灵活方便，一个对象可以被多个线程使用！==**

        ```java
        public class MyRunnable implements Runnable{
        
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println("线程"+i);
                }
            }
        
            public static void main(String[] args) {
                MyRunnable myRunnable = new MyRunnable();
                new Thread(myRunnable).start();
                for (int i = 0; i < 10; i++) {
                    System.out.println("我学习线程"+i);
                }
            }
        }
        
        ```

   3. 实现callable接口		



8. > **线程的可用状态**

   - ==新建==New  ： 新建一个线程对象
   - ==可运行==Runnable :  线程创建后，其他线程调用了该对象的start（）方法。该线程位于可运行线程中，等待被线程调度，获取CPU使用权
   - ==运行==Running  ： 可运行状态的线程获取CPU时间片，执行代码程序
   - ==阻塞== Blocked ： 线程因某种情况放弃了CPU的使用权，暂时停止运行。直到线程进入可运行状态，再次获取cpu时间片 。 阻塞分为==三种== ： 
     1.  等待阻塞 ： 正在运行的线程执行 O.wait()方法，JVM把该线程放入等待队列中
     2. 同步阻塞 ： 运行的线程获取对象的同步锁，锁被别的线程占用，JVM把该线程放入锁池中
     3. 其他阻塞： 
   - 死亡Dead  : 线程run(); main() 方法执行结束，或者因为异常退出run()方法，则该线程结束生命周期。

​      <img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt="线程状态转换" style="zoom:67%;" />



9. > **多线程回调方法？**

   ​	回调 ：  客户程序C调用服务程序S中的方法A，然后S又在某时候反过来调用C中的方法B，对于C来说，B				  就是回调方法。 



10. > **同步方法和同步代码块的区别？为何要同步？**  

    ​	同步方法默认用==this==或者==当前类class对象==作为锁

    ​	同步代码块可以选择在哪儿加锁，比同步方法更细颗粒度。我们可以只同步会发生同步问题的代码块上

    ​	同步方法使用关键字 ==synchronized==修饰方法，而同步代码块主要是修饰需要进行同步的代码,

    ​	使用synchronized(this){ code} 进行修饰

    - ​	为什么要同步？

      当多个线程同时操作一个可共享的变量时，导致数据不准确。比如银行取钱。因此加入同步锁，以避免在当前线程没有结束前，其他线层执行该方法，保证变量的正确性。

    

11. > **sleep() 和wait() 有什么区别   还要yield**     

    1. ​	==sleep==  是线程Thread类的静态方法， 导致线程暂停执行指定的时间，会把执行机会给其他线程，但是 	sleep ==不会释放锁==，到时间之后自动恢复执行  。 需要捕捉 ==InterruptedException==  异常 
    2. ​    wait是Object的方法，作用的是对象本身，==会释放锁==，出让系统资源，使得其他线程可以使用同步方法，并且需要notify/notifyAll 来唤醒进入获取锁的等待队列中，获取锁之后才能执行方法。
    3. yield() :  与sleep不同，sleep出让执行权，不看优先级别。 而yield只会给相同或者更高级别的线程运行机会  。  sleep执行后进入阻塞状态，而yeld进入准备状态。



12. > **同步和异步**

    同步 ： 数据在线程中共享，这些共享数据必须同步，不然无法保证数据的正确型

    异步：  应用程序调用了需要很长时间的方法，并且该返回结果不是我此刻必需的，无需等待，使用异步编程



13. > **run和start的区别**

    启动一个线程是start()  方法，准备就绪，由JVM调度并执行

    启动线程之后，会去调用run方法，创建线程是要重写run方法 ， run方法里面是线程实现的方法。



14. >  **线程同步方法**     见第==三==点

15. >   **synchronized 是可重入锁吗？**

    synchronized 是可重入锁。可重入锁： 当第一次执行同步方法就获得了对象的锁。当同一线程调用自己类中的其他同步方法，都不会阻碍其运行，也就是==同一线程可以获得同一把锁多次==。也就是==可重入==的

    - 原理（可重入机制） ：  每个锁关联一个==线程持有者==和==计数器==，计数器 = 0 ，代表没有线程持有，任何线程都可获得该锁。  当某一个线程获得锁成功后，JVM记录哪个线程获得锁，并且==计数器+1== ；其他线程想获得锁，必须等待。而当前线程再次请求获得该锁，可以==再次==拿到该锁，==计数器+1== 。当线程执行完毕，计数器递减。==直到 0== 。==释放==该锁。



16. >  **synchronized 和  lock的区别**    ==同步和锁的区别==

    1.  synchronized 是关键字 ， lock是接口    `private  Lock lock = new ReentrantLock();`

    2. synchronized  不能判断是否获得锁 ， lock可以判断

       ```
       tryLock() 它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false
       ```

    3.  synchronized 自动释放锁，发生异常也会释放锁 。 lock 在finally中必须手动释放锁(unlock()方法)，不然会发生死锁

    4. synchronized的锁可重入、不可中断，而Lock锁可重入、可中断

    5. synchronized 一个线程阻塞了，第二个线程会一直等待，而lock 尝试获取不到锁，可以不同等待下去

    6. synchronized代码少量的同步，lock适合大量的代码同步问题



17. > **死锁**

    两个或两个以上的线程都在等待对方执行完毕是就发生了死锁。 结果就是无限等待下去。

18. > **反射**

    在程序运行期间获取自身的信息。  主要借助 ： class   constructor   field  method



## 				J V M

19. > **类加载的过程**

    加载  连接（验证、准备、解析） 初始化   使用  卸载

    加载 ：  

    1. 通过全限定类名获得二进制字节流（ ==类加载器==） ，并存储到运行内存的方法区，生成一个==class对象==

       <img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png" alt="img" style="zoom: 50%;" />

       ​	==双亲委派机制== ： 类加载器收到类加载请求，会委托父类加载器去完成，一直向上，最终达到	   

       ​								BootStrap加载器，只有父类加载器反馈加载不了时，子类加载器才会尝试自己加								载，若找不到类，就会==ClassNotFound==。

       ​	好处是：避免重复加载， 确保加载的类==全局唯一==，当出现多个限定名相同时，只会加载某一个类。

2. 验证 ： 验证是否符合class文件规范，不会危害JVM的安全

3. 准备 ： 为==静态变量==分配内存空间，并设置初始值int= 0 ， string = null （对象还没有产生，不包括实例变量）  ==初始化后==，赋值

4. 解析：  将常量池中的符号引用转化为==直接引用==

5. 初始化 ： （==先父后子==）才真正开始执行类中定义的 Java 程序代码，此阶段是执行 `<clinit>()` 方法的 

   ​					过程。  为==静态变量赋值== ， 执行静态代码块。（先父后子）

<img src="I:\KSDownload\javaa.png" style="zoom:80%;" />



20. > **jvm  ==分区==**

<img src="I:\KSDownload\JVM1.png" style="zoom: 67%;" />

​			==方法区  堆   栈  本地方法栈   程序计数器==



21. > ==**新生区==(Eden、幸存区(survial))       ==老年区==**    ==堆==里面的分区

    新生代 和 老年代     新生代包括 （ 伊甸园区  幸存区 分为from区 和 to区）

    对象在==Eden产生==，==from==区保存==幸存==对象， To区为空 ， gc 时  ：   Eden活着的对象 +  from中的存储对象复制到To 区中  ， 然后清空 Eden 和 form  ，  颠倒form  和 to 的关系  ， form 变成  to  ，  to变成 from  。  也就是 ==谁 空  谁是 to  区==    。   ==复制算法==适合存活率低的 区域，gc 频率低， 新生区 。   坏处就是浪费空间 ，永远多出一个  To  区 。每次GC，将对象的年龄 + 1 ，  经过  ==15==  次 GC还存活的对象，进入==老年区==。

 

22. >   **JVM 的 可达性分析算法**      判断对象是否活着？   第一个 引用计数法， 添加引用计数 ，但是不能解决对象相互引用的问题

    GC 要回收无用对象  。  通过可达性分析算法来判断对象是否无用？  通过 一系列 ROOT 对象作为起点 ，开始向下搜索，搜索路径成为引用链。 当一个对象没有任何引用链式，即无用对象。需要回收。

    ==Root 对象 ：==     

    > 1. 虚拟机栈中的引用对象
    > 2. 方法区的静态属性引用对象
    > 3. 方法区中常量引用对象
    > 4. 本地方法栈JNI  引用的对象



23. >   **java内存模型    JMM**

    内存模型规定 所有==变量==存在==主内存==中 ， 每个==线程==有自己的==工作内存==（存储线程共享变量的==副本==） ， 线程对变量的操作必须在自己的工作内存中进行，而==不能直接操作==主内存中的变量。

    -  不同线程之间==无法直接==访问对方工作内存的变量    

    - 线程通信主要有两种 ； 一是  消息传递   二是   共享内存（java线程间的通信）

      <img src="https://upload-images.jianshu.io/upload_images/14923529-55ffcf1994434a48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img" style="zoom:67%;" />

24. > **JVM的内存分配情况**

    1.  堆内存（Java代码可及的内存） :    

         				通过  ==-Xms==初始分配   默认是物理内存的 ==1/64==     -==Xmx== 最大分配内存： 物理内存的  ==1/4==

       ​			当空余堆内存==小于 40 %==  ，jvm会增大内存，直到 -Xmx的最大限制 ； 当空余的内存大于 ==70%==时，减小内内存直到 -Xms的最小限制。

    2. 非堆内存（JVM自己用的，方法区，常数池。栈等） ： -XX  ： PermSize   初始值 为 物理内存的 1/64

       -XX : MaxPermSize 设置最大为  物理内存的 1/4 



25. > **内存泄漏和内存溢出  OOM** 

    - 内存泄漏 ：  不会再被使用的对象的内存==不能被回收==，就是内存泄漏   下面的几种情况
      1. 长生命周期的对象持有短生命周期的引用，会出现内存泄漏     也可利用第二点的解决办法
      2. 变量的作用范围不合理。解决的一个方法 ： ==降低变量的作用域，及时把对象赋值为 null== 
      3.  各种提供close()方法的对象   例如 ：数据库的连接等 ，要在最后调用 close（）方法 
      4. 单例模式中 ： 由于单例对象是以静态变量的方式存储的，所以一直存在，那么单例对象还持有对象A的引用，导致对象A不能被回收。
    - 内存溢出 ： 内存不够了     工具 ：  MAT   Jprofiler



26. > **垃圾回收算法  GC**

    对用范围  ：  ==堆 和 方法区==

    - ==引用计数法== ：对象添加引用计数，基本不用
    - ==复制算法==
      - 无内存碎片，但是浪费空间
    - ==标记-清除法==
      - ==扫描对象==，对活的对象标记，==清除==未标记对象
      - 优点 ： 不需要多余空间
      - 缺点：  产生==内存碎片==
    - ==标记 压缩== 算法
      - 在清除的基础上，再次扫描，使活的对象往一端移动，多了移动的成本
      - 防止内存碎片产生



27. > **Error 和 Exception有什么区别？**

    ==Exception== 是 可预料的异常情况，可以获得这种异常，并处理

    ==Error==  是不可预料的，这个发生之后，导致JVM直接不可处理和不可恢复

    举例错误  ：  OOM   栈溢出错误  

    异常 ：  classNotFound   数组越界     空指针异常  





# Spring等框架类

## Spring

1. >  **Spring的 IOC  和  AOP**

   Spring的组成 ： 

<img src="C:\Users\wangsw\Desktop\File\图片\ppt\spring.png" style="zoom: 67%;" />



**IOC(==控制反转==)  ：**  一种设计思想，将原来的手动创建对象，交给==Spring==来管理、装配和装配 ，而程序本身==被动==的接受对象  。 不需要关心对象怎么 创建的，拿来直接用。

==好处==  ：  集中管理，降低类与类之间的耦合度。

**依赖注入（DI）** :   是实现IOC的一种方法





DI 的==三种==方法  ：   通过==反射==方式实现注入的，在程序的运行期间动态生成对象、执行方法和改变对象														                                                                                             属性

1. 利用Set方法注入  

   - 依赖： bean的创建依赖于Spring容器
   - 注入： bean对象中的==属性==，有容器来注入

   <img src="C:\Users\wangsw\Desktop\File\图片\ppt\2020-07-09_105851.png" style="zoom: 67%;" />

2. 构造器注入   利用`constructor-arg` 注入

   1. 利用index下标赋值

      ```xml
      <!-- 第一种 下标赋值  -->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg index="0" value="wsw"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

   2. 利用参数类型赋值

      ```xml
      <!-- 第二种 使用参数类型赋值 ，不建议使用-->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg type="java.lang.String" value="sss"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

   3. 直接使用参数名**(掌握name赋值就够了)**

      ```xml
      <!-- 第三种 使用参数参数名-->
          <bean id="hello" class="Pojo.Hello">
              <constructor-arg name="name" value="sss"/>
              <!--   property除了value属性还有个ref ，ref指向Spring创建好的bean-->
          </bean>
      ```

3. 接口注入  

```reStructuredText
IOC : 控制反转，是一种设计思想。所有对象都由Spring来创建并管理。IOC容器是Spring用来实现IOC的载体。由容器通过xml、注解来帮我们配置类与类之间的依赖关系，注入依赖对象，程序是被动的接受对象，不需要关心对象是怎么创建的，拿来用即可。注入程序所依赖的对象是通过依赖注入（DI)实现。 
举个例子 ： 当对象A需要依赖对象B共同完成一项任务，之前需要手动new对象，主动创建，A与B就形成了一种依赖关系。现在由Spring来创建管理对象，需要用的时候，spring就会帮我们注入到A中，拿来用即可。依赖注入是通过反射来实现的，在程序的运行期间动态生成对象、执行对象方法。
```



2. > **Spring Bean的生命周期**

   周期的四个阶段 :   ==实例化   属性赋值   初始化   销毁==

   扩展点 ： 两个重要的接口      InstantiationAwareBeanPostProcessor作用于==实例化==阶段的前后，BeanPostProcessor作用于==初始化==阶段的前后

   <img src="https://upload-images.jianshu.io/upload_images/4558491-dc3eebbd1d6c65f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/823/format/webp" alt="img" style="zoom: 50%;" />

   

第二大类 ： Aware类型的接口 和 生命周期接口

- 无所不知的Aware    

  Aware之前的名字就是可以拿到什么资源 ，例如`BeanNameAware`可以拿到BeanName

  `BeanClassLoaderAware`    传入classLoader对象的实例

- 所有的==Aware==都是在==初始化==之前调用的

https://www.cnblogs.com/javazhiyin/p/10905294.html

```xml
1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后将值注入到Bean的属性中
			检查 Aware 接口 
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
		//	BeanPostProcess 前处理			开始 初始化 
6. 实现了BeanPostProcessor接口，Spring调用他们的postProcessBeforeInitialization()方法。		
		//	检查 InitializingBean 接口   
7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
		//	BeanPostProces后处理
8. 进行后处理，Spring调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。
```



3. > **Spring注解  @Autowore  和@Resource的 区别**

   共同点 ：  都可以写在字段 和 setter方法上

   不同点 ： 

   - ​	 `@Autowire`    是按照类型  ==ByType==  自动注入的，默认情况下 依赖的对象必须存在。要允许	==null==值，可以设置它的r==equired属性为false==       如果需要按照name 装配   ，结合`@Qualifier`使用		
   - `@Resource`   默认按照  ByName 装配   。 有两个属性 ， name  和  type ，将name解析为bean的名称，type解析为 bean的类型。  指定name名，就使用  ByName  ， 指定Type属性，就用 ByType 注入

   

4. > **SpringBean的 作用域**

   ![](C:\Users\wangsw\Desktop\File\图片\ppt\2020-07-09_163934.png)

   默认使用单例的，唯一的实例

   prototype（原型模式） ： 每次get 都会创建新的bean 实例

   request  ：  每次 http 请求都会创建新的bean  ，仅在当前 requset内有效

   session ：  每次 http 请求都会创建新的bean  ，仅在当前 session内有效



5. > **Spring的自动装配** 

   ByName  ：  按照Bean的 名字， 即 Bean 的  id

   ByType  ：  按照Bean 的类型  ，  即Bean 的 class



6. > **Spring的注解有哪些？**

   一般使用`@Autoware`   默认按照类型注解来装配bean 

   `@Resource`  默认通过 name装配bean

   `@Bean`     作用在方法上

   `@Compoent`   放在==类==上  ，说明被Spring管理了。如果一个bean不知道属于哪一层，用这个标记

   - ​	衍生的注解，对应MVC三层架构
   - Controller 【@Controller】  用户接受请求并返回数据
   - Dao  【@Repository】   数据库操作
   -  Serivce【@Service】   服务层  涉及复杂的逻辑



7. > **Spring中BeanFactory 和ApplicationContext的区别？**

   - BeanFactory 是 古老的 factory，是最底层的接口，创建和管理bean。 ApplicationContext 是他的子类，对其功能进行了扩展。  包括 ==继承 MessageSource ，支持国际化      统一资源访问方式  同时加载多个文件  不同层次的context的实现==
   - BeanFactory 是==延迟加载==来注入bean ， 只有在使用的时候，才对Bean实例化。 这样导致不能一开始发现存在的问题。加载的时候才会发现问题。==节约内存，速度慢==
   - ApplicationContext  是容器启动的时候就==一次性创建==所有的bean，如果有错误可以一开始发现。预加载单例的Bean，需要用的时候直接拿来即可。   预先加载，浪费内存空间。
   - 一般使用ApplicationContext ，功能更强大。



8. > **==A  O   P==**

   - https://www.cnblogs.com/zhuifeng523/p/11552187.html
   - 面向==切面==编程 ，作为面向对象的补充，==将那些与业务无关的，却为业务模块所共同调用的逻辑或责任封装起来，减少代码的重复，降低模块的耦合度，有利于可扩展和可维护性==。 不修改代码的情况下，实现功能的增强

   - **应用场景** ：  

     ```xml
     记录日志 
     权限
     缓存 
     事务管理 （调用方法前开启事务，方法后，提交事务）
     监控记录跟踪
     性能优化
     异常错误处理
     同步   。。。。
     ```

     https://blog.csdn.net/u010452388/article/details/80868392

     AOP的原理 : ==动态代理==

     - JDK动态代理 ：  基于接口的动态代理
     - cglib动态代理 ： 基于类的代理

     两者的==区别== ： 

     JDK ： 只能对==实现接口的类==生成代理，不能针对类。通过==反射==生成。

     Cglib: 针对类实现代理，通过继承的方式，主要是对指定的类==生成一个子类==，覆盖其中的方法（==继承==）。由于生成子类，不能对声明为==final==的类进行代理。  通过==字节码技术==，==效率比JDK高==。

     ```java
     Spring在选择用JDK还是CGLiB的依据：
     
     (1)当Bean实现接口时，Spring就会用JDK的动态代理
     
     (2)当Bean没有实现接口时，Spring使用CGlib是实现
     
     (3)可以强制使用CGlib（在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）
     ```

     两种==动态代理==怎么实现的？

     ==JDK  ：==  

     ```java
     //-------------------
     public interface Rent {
         public void rent();
     }
     
     public class Host implements Rent {  // 真实角色
         @Override
         public void rent() {
             System.out.println("Host要出租房子！");
         }
     }
     // 用这个类，自动生成代理类
     public class ProxyInvocationHandler implements InvocationHandler {
     
         private Object target;   // 这个就是接口
     
         public void setTarget(Object target) {
             this.target = target;
         }
     
         //生成代理类  param(ClassLoder,interface,InvocationHandler)
         // 由于本身实现了InvocationHandler接口，传入this本身即可
         public Object getProxy(){
             return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
         }
     
         // 处理代理实例并返回结果
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
             // 动态代理的实质，就是使用反射机制实现
             Object result = method.invoke(target, args);  //调用接口的方法
             return result;
         }
         //--------------------------------------
         public void Seehouse(){
             System.out.println("看房子");
         }
         public void Fare(){
             System.out.println("收房租");
         }
     }
     //----------------------------------------测试
     public class Client {
         public static void main(String[] args) {
             //真实角色
             Host host = new Host();
             //代理角色   目前没有
             ProxyInvocationHandler pih = new ProxyInvocationHandler();
             pih.setTarget(host);
             // Proxy就是动态生成的代理
             Rent proxy = (Rent) pih.getProxy();
             proxy.rent();
         }
     }
     
     ```

     1. 定义一个类，实现`InvocationHandler` 接口

     2. 获得代理对象，通过 `Proxy.newProxyInstance`  

        三个参数是  ：  param( `ClassLoder, interface, InvocationHandler`)

        ​						<u>**指定的ClassLoader ; 要实现的接口 ； 传递进来的处理者。来生成真正的代理类**</u>

     3. 重写==invoke==方法，调用

      

     ==Cglib 代理==： 采用继承的方式，生成目标类的子类

     ```java
     public class CglibProxy implements MethodInterceptor {
     	// 获取代理对象
         public <T> T getProxy(Class<T> clazz) {
                       两个参数 ：  被代理的class ， 回调函数  就是 MethodInterceptor
             return (T) Enhancer.create(clazz, this);
         }
     
         @Override
         public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
             before();
             Object result = methodProxy.invokeSuper(o, objects);
             after();
             return result;
         }
     
         private void before() {
             System.out.println("cglib proxy before ...");
         }
     
         private void after() {
             System.out.println("cglib proxy after ...");
         }
     }
     //----------------------------------------测试
     public class Client {
         public static void main(String[] args) {
             //真实角色
             Host host2 = new Host2();  // 类，不实现接口
             //代理角色   目前没有
             new MethodInterceptor();
             // Proxy就是动态生成的代理
             Host2 proxy = (Host2) pih.getProxy(host2.getClass());
             proxy.rent();
         }
     }
     
     ```

     1. 定义代理类实现  `MethodInterceptor`接口
     2. 获得代理对象  ， 通过`Enhancer.create(class,methodInterceptor)`  传入要代理的对象的class
     3. 重写 `intercept` 方法，调用==invokeSuper==；

     

   9. > **AOP中的连接点(Joinpoint)、切点(Pointcut)、通知(Advice)、切面(AOP)**

      Joinpioint :  执行过程中的明确点，一般是方法的调用

      切点 ： 切点表达式，定位类

      Advice ： 在切入点执行的增强处理。 before  after   afterReturning    afterThrowing    aroud

      

      五种通知 ： 

      1. 前置通知 ： 在方法执行之前（@==Before==）
      2. 后置通知：  方法执行之后  （@==After==）
      3. 返回通知： 目标方法正常返回值后（@==AfterReturning==）
      4. 异常通知： 方法出现异常之后（@==AfterThrowing==）
      5. 环绕通知： 动态代理，需要手动执行 joinPoint.==proceed==方法，相当于前四种的结合体

      

      > **SpringAOP 和 AspectJ Aop有什么区别？**

      ​	Spring AOP 是运行时增强 ， 而AspectJ 是编译时增强，  Spring是基于动态代理，而AspectJ 基于字	节码操作的。AspectJ 相比于AOP功能更强大，SpringAOP相对更简单。
   
      

   10. > **Spring支持的事务管理类型有哪些？**

       - 事务的四个特性 ==ACID  原子性  一致性  隔离性  持久性==
    - 声明式事务   :  利用==AOP==来切入事务
       - 编程式事务   : 在代码中显示调用开启事务。提交。回滚，不推荐

       事务的父接口是 `PlatformTransactionManager`，定义了三种方法，他的实现类必须实现开启事务、提交事务、回滚事务

       事务的隔离级别 ： 若干个并发事务的隔离程度

       -  默认的隔离级别  TransactionDefinition.ISOLATION_READ_COMMITTED   

   ​							==一个事务只能读取另一个事务提交的数据==
   
   ​	事务的传播特性 ：`REQUIRED`  Spring  默认的      
   
   ​	指的是  ==如果上下文已经存在了一个事务，有选择的指定一个事务的执行行为==
   
   ​				==required  :  当前事务就加入他，没有就新创建一个事务==、



## SpringMvc

Springmv围绕==DispatcherServlet==设计的，作用就是把请求分发到不同的处理器



1. > **SpringMvc的处理步骤**

   > 1. **根据用户请求的控制器（/hello），首先经过==DispatchServlet==**
   > 2. **由DispatchServlet调用handlerMapping处理器映射**
   > 3. **根据hello查找处理器，主要由==HandlerExecutiuon==来查找，找到==Handler==传递给DispatchServlet** 

   > 4.  **==HandlerAdapter==表示处理器适配器，按照特定的规则去执行Handler**
   > 5.  **Handler让具体的==Controller==执行，就是需要执行的代码**
   > 6.  **Controller将具体的==ModelAndView==(数据和视图)返回给HandlerAdapter**
   > 7.  **HandlerAdapter将结果给DispatchServlet**

   > 8. **DispatchServlet调用视图解析器==Viewresolver**==
   >    1. **获取了ModelAndView的数据**
   >    2. **解析视图的名字**
   >    3. **拼接视图名字，找到对应的/web-inf/jsp/&.jsp**
   >    4. **将视图渲染到视图上**
   > 9. **DispatchServlet根据视图解析器的结果，调用==具体的视图==**
   > 10. **最终将==视图呈现==给用户**

![image-20200806223146363](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200806223146363.png)



2. > **RestController  和 Controller   的区别？**

   - 单独使用Controller 只返回一个视图
   - RestController 是Controller 和 responseBody 的结合 ，返回json 或者 xml形式的数据



3. > **Spring框架的设计模式？**   ==之后解决==



## Mybatis

> **什么是Mybatis**

Mybatis是个ORM半自动框架，对JDBC进行封装，用XML文件或者注解配置原生信息。



1. > **#{} 和 ${} 的区别是什么？**

   ==${}== 是 Properties文件红的==变量占位符==，静态文本替换，比如在Properties中定义了driver ，在配置文件中使用$会被替换为 com.mysql.jdbc.driver

   ==#{}== 是sql中的占位符，Mybatis会将 #{} 替换为 ？ ；sql在执行前会根据？设置参数值，其取值方式是使用反射从对象中获取参数的值。



2. > **XML 映射文件中，除了 常见的增删改查标签之外，还有什么？**

   ```xm
   <resultMap> <parameterMap> <sql>  <include>
   sql的动态标签   <trim> <where> <set> <foreach> <if> <when>
   ```



3. > **通常⼀个 Xml 映射⽂件，都会写⼀个 Dao 接⼝与之对应，请问，这个 Dao 接⼝的⼯作原理是什么？Dao 接⼝⾥的⽅法，参数不同时，⽅法能重载吗？**

   Dao接口，就是说的Mapper接口，就是==namespace==的值。==全限名==

   ```xml
   <mapper namespace="com.nuaa.dao.***Dao">
   ```

   接口的==方法==名，就是映射文件中==MapperStatement==的==id==值。接口方法内的参数，就是传递给sql的参数。Maper接口是没有实现类，当调用接口方法，根据 ==全限名 + 方法名==拼接字符串作为key值，可以定位一个唯一的==Mapperstatement==。每CRUD标签都会解析成一个==MappertStatement==对象。

   Dao接口的方法，不能重载。因为是 ==全限名 + 方法名==  查找。

   Dao接口的工作原理 JDK ==动态代理==，为Dao接口生成代理对象，代理对象拦截接口方法，执行sql将结果返回。



4. > **Mybatis 和 Hibreanate 有哪些不同** ？

   Mybatis ==不是==一个完全的ORM框架，因为 Mybatis 需要程序员自己编写sql语句

   sql灵活 ， 但无法做到数据库无关性，如果需要支持多种数据库，需要些多套sql语句

   Hiberanate 对象/关系映射能力强，数据库无关性好，可以节省很多代码。



5. > **Mybatis 中一级缓存与二级缓存的区别**

   避免频繁操作数据库，将查询的数据放入缓存中，下次直接从缓存中读取。

   默认开启一级缓存，在操作数据库时构造sqlSession对象，对象中存储数据。不同的sqlsession的缓存区域互相==不影响==，相互之间==不能读取==。

   当进行增删改的操作时，会==清空缓存==。防止出现脏读。

   - Spring整合Mybatis时，在==未开启事务==的情况下，每次查询，都会关闭旧的sqlSession，创建新的，也就是一级缓存没有意义了。
   - 在==开启事务==的情况下，spring使用ThreadLocal 获取当前的资源的同一个SqlSession，一级缓存有效。



6. > **当实体类中的属性名和表中的字段名不一样 ，怎么办 ？**

   - 在sql语句中定义字段的别名
   - 通过<resultMap>来映射字段名和实体类名



7. > **ResultType  和  ResultMap 的区别**

   基本映射(==resultType==)  ： 使用resultType进行映射输出时，查询的列名要和pojo中的属性名一致才能映射成功

   高级映射(==resultMap==) :查询的列名和pojo 的属性名==不一致==，通过定义一个resultMap对列名和属性名做==映射==。



## Shiro

> **什么是shiro？**

Shiro是一个简单安全框架。可以帮助我们完成 ： ==认证 授权 加密 会话管理  与Web集成   缓存==等。

三个核心概念 ： ==Subject   Security   Realms==





1. > **Shiro的Subject 、SecurityManager 、Realm**

   - Subject  :  主体 ，代表当前“==用户==”，指的是与当前应用交互的任何东西都是Subject

     所有的Subject 都绑定到SecurityManager ；SecurityManager才是实际的执行者 。 

   - SecurityManager : ==安全管理器==； 所有与安全相关的操作都会SecurityManager 交互；且管理着所有的subject
   
   - Realm ： 域 ； shiro从Realm 获取安全数据(角色、权限等)；即 SecurityManager要验证用户身份，那么他需要从Realm中获取相应的信息比较用户是否合法；验证角色的权限。 可以把Realm看成DataSource数据源
   



2. > **Shiro的核心组件**

   ​	Authenticator: 管理登陆登出；==核查用户==
   ​	Autorizer:==授权==器赋予主体有那些权限
   ​	session Manager：shiro自己实现session管理器
   ​	session DAO：提供了session的增删改插
   ​	Cache Manager：缓冲管理器
   ​	Raelms：和数据库交互的桥梁



3. > **Shiro认证的过程**

   - 调用 Subject .login 方法，传递身份和凭证；然后委托给 SecurityManager，SecurityManager委托给Authenticator 进行身份验证
   - Authenticator 进行身份验证，把相应的登陆token传入Realm获取验证信息。
   - 认证策略 ：  FirstSuccessfulStrategy  AtLeastOneSuccessfulStrategy   AllSuccessfulStrategy
     - 只要一个Realm成功，只返回第一个，其他忽略
     - 只要一个成功即可，返回所有Realm验证成功的信息  （ ==默认==）
     - 全部验证通过才返回信息，否则失败



4. > **Shiro 授权的过程**

   - 调用 Sunject.isPermitted / hasRole ， 委托给SecurityManager，==SecurityManager==委托给Autorizer 进行授权
   - 在授权之前，会调用相应的Realm获取角色的权限
   - 比较是否和传入的权限匹配，如果右多个Realm，会进行循环判断，匹配则返回true，否则返回false。

5. > **注解**

   > **@RequiresRoles(value = { “admin”, “user” }, logical = Logical.AND)** : 表示当前 Subject 需要角色 admin和user
   > **@RequiresPermissions(value = { “user:a”, “user:b” }, logical = Logical.OR)** : 表示当前 Subject 需要权限 user:a 或 user:b



# 计算机网络

1. > **OSI七层协议 和 五层协议体系结构**

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200818213707819.png" alt="image-20200818213707819" style="zoom:50%;" />

   从上到下解释各层的作用

   **应用层** ： 通过应用进程间的交互来完成特定网络应用。应用层协议定义的是进程（进程主机中==正在运行的程序== ）间的通信和交互的规则。  协议有很多 ： ==域名服务DNS   HTTP协议  SMTP协议==

   **运输层**： 主要任务:  负责 两个进程之间的**通信**  提供通用 的==数据传输服务==， `传输应用层报文`

   运输层主要两种协议 ：

   - ​	TCP   传输控制协议   --- 提供**面向连接**的 ， **==可靠的==**数据传输协议
   - ​    UDP   用户数据协议  ---  提供**无连接** ，尽最大努力的数据传输服务（==不保证==数据传输的==可靠性==）

   **网络层** ： 两个计算机通信时，可能会经过很多个数据链路，也可能会经过很多个通信子网。 任务就是 ：
   
   ​				选择合适的网间路由和交换节点，确保==**数据及时的传输**==        使用 ==**IP协议**==
   
   **数据链路层** ： 简称链路层。  两台主机间的数据传输 ，总是在链路上传送的，需要专门的链路层的协议。
   
   在两个相邻的节点传输数据时，数据链路层将网络层的**==IP数据报==**组装成==帧== 。 在两个相邻节点间的链路上传送帧。==每一帧==包括数据和必要的==控制信息==。 通过控制协议将差错的物理信道变为无差错的、可靠传输的数据链路
   
   **物理层** ：  利用传输介质为数据链路层提供==物理连接==，实现比特流的透明传输，尽量屏蔽具体传输介质和物理设备的差距。
   
   
   
2. >  **TCP 三次握手  四次挥手  （ ==面试高频==)**

   -  三次握手    目的  ： 为了建立==可靠的==通信信道，准确无误的把数据送到目标处。最主要的就是==双方确认自己与对方的发送与接收是正常==

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200819183257810.png" alt="image-20200819183257810" style="zoom: 50%;" />

客户端--发送带有 ==SYN== 标志的数据包  第==**一**==次握手  --- 服务端

服务端--发送带有 ==SYN / ACK== 标志的数据包  第==**二**==次握手  --- 客户端

客户端--发送带有 ==ACK== 标志的数据包  第==**三**==次握手  --- 服务端

第一次握手 ： Client 什么也不能确认 ，Server确认了对方发送正常，自己接收正常

第二次握手 ： Client确认了： ==自己==发送，接收正常，==对方==发送正常。接收正常。 Server ： 对方正常，自己接收正常。

第三次握手 ： Client  和  Server 都确认 对方发送正常，接收正常。自己接收正常，发送正常。 



- 为什么要传回SYN?

  接收端==传回==发送端所发送的==SYN==是为了告诉发送端，我==接收到的信息确实就是你发送的信号==。

- 传了SYN，为什么还要传ACK？

  双方通信必须确认两者发送的信息都无误。SYN证明==传送方的通道==没问题，但是==接收方到传送方的通道==还需要==ACK==信号来确认



3. > **四次挥手**

   断开TCP连接 ： 需要四次挥手



<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200821091444262.png" alt="image-20200821091444262" style="zoom:50%;" />



- 客户端-- 发送一个FIN，用来关闭客户端到服务端的数据传送
- 服务端--收到FIN，并且发送一个ACK，表明收到客户端的请求
- 如果服务端没有数据要传输，想要断开连接，和第一次挥手一样，发送FIN报文，释放连接
- 客户端接受到FIN之后，发送ACK作为应答，服务端接受到后，关闭TCP连接。



​		==为什么==要进行四次挥手？

- 任何一方在数据结束之后，发出连接释放的通知，待对方确认之后进入半关闭状态。当对方也没有数据传输之后，则发出释放连接的通知，对方确认后关闭连接。



4. > **TCP、UDP的区别？**    视频电话是==UDP==协议，要求传输效率高！！

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200821093923363.png" alt="image-20200821093923363" style="zoom: 67%;" />

   UDP在传输是==**不需要**==先建立连接，对方收到UDP报文之后，不需要给出任何确认。虽然提供不可靠连接，用于及时通讯。

   （QQ语音、视频等）

   TCP： 面向连接的、可靠的传输服务，先建立连接，数据传输结束后，释放连接。（文件传输、传送、接受邮件等）



5. > **TCP如何提供可靠的连接？**

   1. 数据被==分割==成合适发送的==数据==块
   2. TCP对每一个包进行==编号==，接收方将数据包进行==排序==，把数据传给应用层
   3. **校验和** ： TCP保持它首部和数据的校验和。目的是==检测数据==在传输过程中的任何==变化==。如果检验和有差错，TCP将丢弃这个报文
   4. TCP的接收端会丢弃重复的数据
   5. **流量控制** ： TCP连接的每一方都有个==固定大小的缓存空间==。接收端只接收缓存区能接纳的数据。当接受方来不及处理发送方的数据时，能提示发送方降低发送频率。 流量控制协议 ：  滑动窗口协议
   6. **拥塞控制** ： 网络拥塞时，减少数据的发送
   7. **ARQ协议** :  基本原理:  每发完一个分组就停止发送，等待对方确认。收到确认后在发下一个分组。
   8. **超时重传**： 当TCP发出一个段后，启动一个==定时器==；等到对方确认收到这个报文段。如果==不能及时收到确认==，将==**重发**==这个报文段

​	

6. > **ARQ协议**    自动重传请求

   通过使用确认和超时两个机制，在不可靠服务实现可靠的传输。 在发送方在一定时间内没有收到确认信息，通常会重新发送。

   包括 `停止等待ARQ` ； `连续ARQ`

   - **停止等待ARQ**：

     - 为了实现可靠的传输，基本原理就是每分发完一个分组数据就停止发送，==等待对方确认==(回复ACK)。过了一定时间后没有收到确认，就重新发送，直到收到确认后，发送下一个分组。
     - 若收到重复的分组就丢弃，但是也要发送确认。

     有下面三种情况：

     1. **无差错情况**

        - 接收方收到数据==并返回确认==，发送方再次发送

     2. **出现差错情况（超时重传）**

        - 超时重传：在规定时间内发送方并没有收到确认信息，就会重传前面发送的分组。(==超时计时器==)
        - 若收到重复的分组，就丢弃该分组，但是要返回确认信息。

     3. **确认丢失和确认迟到**

        1. 确认丢失 ： 确认消息在传输途中==**丢失**==。【当**A**发送M1消息，**B**收到信息并返回确认信息，但是==确认信息==在途中==丢失==导致A并没有收到。而==A并不知道==，就==重发M1==消息，B再次收到信息后采取以下措施：】

           （1） `丢弃该信息，不先上交付`  （2）  `发送确认信息`。（A能重传说明确认消息丢失了）

        2. 确认迟到： 确认消息在传输过程中==**迟到**==。**A**发送M1消息，**B**收到后发送==确认信息==。在超时时间内并没有收到确认消息，就重发M1消息，B任然收到并发送确认信息。此时A收到新的确认信息，发送下一份信息。过一会后，A收到了第一份确认信息。 处理如下 ： （1） ： `A收到重复确认，直接丢弃`  （2） `B收到重复的M1信息，直接丢弃重复的M1信息`。

           

   - **连续ARQ协议**

     能个**提高信道的==利用率==**。发送方==维持一个窗口==，位于这个窗口的分组可以连续发送，==不需要==等待对方确认。接受方一般采用连续确认，对按序到达的最后一个分组发送确认，代表到这个分组为止的所有分组都正确收到了。

     **优点**  :  信道利用率高，容易实现。

     **缺点**：不能向发送方反应所有已经接受到的信息。 【eg. 发送方发送五条信息 ，中间第三条丢失了。这时候==接受方只能对前两个信息确认==。发送方无法知道后面三个信息的下落，只能==重新发送后三个信息==。】



8. > **滑动窗口 和 流量控制**

   TCP利用==滑动窗口==实现**流量控制**。目的是为了控制发送方的发送效率，保证接收方来得及接收。

   接受方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送速率。



9. > **拥塞控制**

   **拥塞** ： 对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能变差。

   拥塞控制 ： 为了防止过多的数据注入到网络中，这样就可以是网络中的路由器不至于过载。

   是个==**全局性的过程**==，涉及到所有主机、路由器等因素。  流量控制是端到端的控制。

   - 为了进行拥塞控制，TCP发送方要维持一个==**拥塞窗口**（cwnd）==的状态变量。窗口的大小取决于网络的拥塞程度，并且动态变化。取得是发送方和接受方窗口较小的一个。

- 拥塞控制的四大算法 ： 慢开始、拥塞避免、快重传、快恢复

  - **慢开始**  ： 基本原理 ： 由于不知道网络的符合情况，先 进行探测，即==由小到大逐渐增大拥塞窗口==的数值。初始值从1开始，每经过一次，==cwnd==加倍。

  - **拥塞避免** ： 思路 --：  让拥塞窗口缓慢增大，即每经过一个往返时间，就把 ==cwnd== +1 ；

  - **快重传与快恢复(FRR)** ：能快速回复丢失的包。【没有FRR，如果数据包丢失了，TCP会使用定时器来要求传输暂停。在暂停的时间内，没有数据包发送。】  ==有了FRR==，若接收机收到了不按顺序的数据段，

    会立刻给发送端发送重复确认。若发送机收到三个重复确认，会假定数据段丢失，并立刻重发这些数据段。不会因为丢失而暂停耽搁。



10. > **在浏览中输入一个url--->  显示页面的过程**

    

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200822214453259.png" alt="image-20200822214453259" style="zoom: 50%;" />

过程 ：  先==DNS==进行域名解析，获取对应的==ip==  ； TCP: 与服务器建立==TCP连接==

​			 发送HTTP请求 ， 服务器处理请求并返回HTTP报文，浏览器解析渲染页面



11. > **状态码**

    ![image-20200826222120101](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200826222120101.png)

    

    https://blog.csdn.net/weixin_42292229/article/details/105240877?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param



12. > **HTTP长连接、短连接**

    HTTP/1.0 默认使用==短连接==。 客户端和服务端每进行一次HTTP操作，就建立一次连接。任务结束就中断连接。当客户端访问页面资源的时候，每访问一个资源，就会出现建立一次HTTP会话。

    ==长连接== ：  保持连接特性。当一个网页打开后，客户端和服务器之间的TCP连接不会断开，当客户端再次访问这个服务器时，会继续使用这个建立的连接。 但并不是永久性的，会有一个持续的时间。 实现长连接需要客户端和服务端都支持长连接。



13. > **HTTP不保存状态的协议，如何保存用户的状态**

    HTTP是无状态协议，不保存状态。  Sesssion机制的主要作用就是通过==服务端记录用户的状态==。当用户进行的一系列操作，服务端给特定的用户创建特定的Session，从而跟踪这个用户（Session是有==期限==的，过了时间，会销毁这个Session）。

    **Cookie 被禁用怎么办？**     【常用的就是利用URL重写把Session Id 直接附在URL路径的后面】



14. > **Cookie  和 Session 的区别？**

    **Cookie  和 Session 都是用来跟踪浏览器用户身份的，应用场景不太一样。**

    - **==Cookie==**   保存用户信息 ，存储在 ==**浏览器中**==（客户端中）的数据。

      > 1. **服务端接受请求之后，建立一个Session ,并发送HTTP响应给客户端 ，这其中就==包含Set-cookie头部==。该头部包含了Session-ID，即相当于用户的标识，让服务器知道这个人是谁！**
      > 2. **第二次请求的时候，如果服务器给了Session ， 就会在请求头中添加 Cookie**
      > 3. **服务器接受请求，验证信息 ， 核对成功后返回resonse给客户端**

      <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200827214720579.png" alt="image-20200827214720579" style="zoom:67%;" />

    而 Session 是把用户的信息存储在服务端的 。

    e.g  购物车行为 ，添加商品到购物车， 服务端要知道谁添加了商品。所以要给客户端分配“==**身份标识**==”，对于浏览器采用cookie保存。每次请求的时候带上session-ID 就行了。

    -  ==**Token**==

      基于Token的身份验证是==无状态==的，不将用户的数据存在服务器中。

      > 1. **用户通过用户名和密码发送请求**
      > 2. **程序验证，成功后返回一个签名的token给客户端**
      > 3. **客户端每次请求带着token**
      > 4. **服务器采用过滤器验证token，成功返回请求的数据，失败返回错误信息**

    - session 存在服务器中，有着唯一识别符号session-ID ， 通常放在cookie中。服务器收到cookie解析出session-ID，知道是哪个用户

    - cookie是用户的通行证，存储在客户端

    - token也是身份令牌，==**无状态**==，用户信息加密在token中，服务器收到解析解密知道是哪个用户



15. > **URL 和URI 的 区别什么？**

    URI  ： Uniform Resource Identifier   统一资源标志符  ， 可以标识 ==唯一一个资源==

    URL ： Uniform Resource Location   统一资源定位符 ， 提供访问该资源的==地址==  ， 也是一种 URI

    URI 相当与人的身份证号 ， 唯一确定一个人 ；  

    家庭住址相当于 URL ，通过地址也能找到人，通过定位找到人。

    ==**URL 是 URI的子集**== （URI是通过某一规则标识一个资源，通过路径是规则的一中）



16. > **HTTP 和HTTPS 的区别？**

    1. 端口 ： HTTP的URI 由 http://  起始且默认使用端口为 80 ，而 HTTPS 的 url 是 "HTTPS://" ，默认端口443
    2. 安全性 和资源消耗 ： **HTTP**协议运行在TCP上 ，所有传输的内容是==明文== ，客户端和服务器端是无法验证对方的身份。而 **HTTPS**是运行在SSL/TLS上的协议，SSL/TLS运行在TCP上。所有的传输内容都经过加密。 所以 HTTP 安全性没有HTTPS高，但是HTTPS耗费更多资源。
       - 对称加密 ：  密钥只有一个 ，加密解密为同一个密码，且解密速度快。典型的有 DES、AES等
       - 非对称加密： 密钥成对出现（==公钥无法推知私钥；私钥也无法推知公钥==）。同时加密解密使用不同的密钥，相对于对称加密来说，加密速度慢。典型的有 RSA、DSA等。





# MySQL

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200828215822013.png" alt="image-20200828215822013" style="zoom:67%;" />

- **连接层** ： 连接处理、身份验证、授权。
- **服务层** ： 完成大部分核心功能 ：查询解析、分析、优化、缓存。所有的内置函数【分析器、优化器、执行器】
- **引擎层** ： 负责MySQL中数据的存储和提取。MyIASM  Innodb 等
- **存储层** ： 将数据持久化到硬盘上

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200829130548701.png" alt="image-20200829130548701" style="zoom:67%;" />

MySQL的查询流程 ： 客户端请求 --- **连接器**（验证身份，授予权限） ---- **查询缓存**（存在缓存直接返回）--

**分析器**（对SQL语句进行语法分析） ----  **优化器**（对执行的SQL优化选择最优的执行方案）---  **执行器** ---

去引擎层==获取数据==。 



数据库引擎：

**InnoDB  和 MyISAM的区别？**

> 1. **Innodb支持==事务==，MyISAM不支持事务。这是MySQL将默认数据库变为Innodb的主要原因**
> 2. **Innodb支持外键，MyISAM不支持外键；将带有外键的Inodb转化为MyISAM会失败**
> 3. **InnoDB是聚簇索引，文件数据放在主键的索引叶子节点上，并用指针连接在一起。Innodb必须有==主键==，通过主键索引==效率很高==。而辅助索引(叶子节点存放的是==KEY字段加主键值==)需要两次查询，先查询到主键，在通过主键查到数据。**
> 4. **==Innodb==最小的粒度是==行锁==；==MyISAM==最小的锁粒度是==表锁==。一个更新语句会锁住整张表，导致其他更新和查询都会被阻塞。也是 将默认引擎设置成Innodb的重要原因。**





1. > **哪个存储引擎执行 select count(*) 更快，为什么?**

   MyISAM 在磁盘上存储了表的总行数。直接调取就行了。而InnoDB每次都需要查询整个表的总数据，然后返回值。
   
   为什么Innodb不存表的行数？ --- 【跟innodb事务有关，由于==MVCC==的原因（==多版本并发控制==），表应该返回多少行是无法确定的】



2. > **Mysql常见的数据类型？**

   整数类型 ： int  常用 tinyInt(0-255)

   字符串 ： char (固定长度) varchar(长度可变)   text 

   浮点类型： double  float

   日期类型 ：  Date  time  DateTime
   
   

## 索引

3. > 索引问题 ：
   >
   > 数据库索引的原理？为什么用B+树，不用B-tree，不用二叉树
   >
   > 聚簇索引和非聚簇索引    索引策略   常见索引的方式

   什么是索引？  官方定义 --- ：能够==高效==的获取数据的==**数据结构**==。

   索引本身也很大，不可能全部存在内存中，一般以文件形式==存在磁盘==上。

   ==优点== ：提高查询的效率，降低数据库IO成本 ； 降低数据排序的成本，降低CPU的消耗

   ==缺点==： 降低更新。添加、删除的速度。 更新表的时候，不仅要保存数据，还要调整索引的信息

   ```SQl
   CREATE [UNIQUE] INDEX idexName ON TableName
   DROP INDEX[indexName] ON mytable
   SHOW INDEX FROM table_name;
   ALTER TABLE Name ADD PRIMARY KEY(colnum_list)  # 添加主键
                    ADD UNIQUE index_Name  # 唯一索引
   ```

   **主键** :  是一种特殊的唯一索引，一张表中只能有一个主键索引。唯一标识一条记录 。 【PRIMARY KEY】

   **普通索引** ： 每个索引包含单个列 ，允许该列包含重复的值。

   **唯一索引** ： 在普通索引的基础上，列不允许有重复的值。 【UNIQUE】

   **复合索引(联合索引)**  ：  在多个字段上创建索引。只要查询是使用了创建时的第一个字段，索引就会被使用。必须遵循 ==**最左前缀匹配准则**==



4. > **B+ Tree         B-Tree**

   数据读取到内存中 是 以磁盘块为单位的 。==位于同一磁盘块的数据会一次性读出来== 。

   InnoDB 引擎 中最小的磁盘管理单位 是 ==**页**==。默认是==16== KB 



​		==B-Tree== 

​		定义了一个二元组 ==[key,data]== ； key 存储的是==主键值==  ；  data ： 一条记录==除主键外的数据== 。

![image-20200830212354734](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200830212354734.png)

记录了 【17-35】的数据 ，小于 17 的数据在p1 指向的节点 ， 依次类推



​		==**B+Tree**== 

​		在B_Tree的基础上进行优化 。  B_Tree ==每个节点==都包含==数据的 key  和 data== 。每页的存储有限，data的数据量很大会导致key的数量很小。当存储量上来是会导致树的==深度较大==，==增大IO次数==；影响查询的效率。

> 几点不同 ：   **非叶子节点只存储==键值信息== ；  数据记录在叶子节点上  ；  所有叶子节点之间用链指针相连。**

![image-20200831085704800](C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831085704800.png)



**B+Tree的性质** ：

1. IO的次数取决于B+树的高度 h ，假设 数据记录为 N ，每个==磁盘块==的数据项数量为m 。 则 ==h= log(m+1)N== 。m越大，h越小。 m = 磁盘大小/ 数据项的大小 ； m -- 磁盘数据项数量越大，树的高度越小。所以==索引字段要尽量的小== 。一旦把数据放在内层节点，磁盘块的数据项会大幅度下降，导致树增高 。


2. **索引的最左匹配原则(复合索引)** :  比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的。比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的==最左匹配特性==。



- 文件很大，不可能全部存在内存中，存在磁盘中
- 索引的结构要减少查找过程中的磁盘IO次数
- B/B+树利用了磁盘的预读原理，将一个节点设置成一个磁盘页的大小，每个节点只需要一次IO即可。而红黑树的节点虽然相邻，但是在物理结构上可能会差很远。需要多次的IO查找数据



> **为什么索引用==B+==树而不是B树？**
>
> **B+树只有叶子节点才存储数据，目的是为了提高区间访问的性能。B+树支持区间查找非常方便。只需要将叶子节点扫一遍即可。而虽然提高了磁盘的IO性能但是，B树得遍历元素的效率低下。**



5. > **非聚簇索引**

   **索引文件和数据文件时==分离==的**。MyISAM的数据域存放的不是数据记录，而是数据的地址。

   <img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831154506888.png" alt="image-20200831154506888" style="zoom:67%;" />

==主索引==是指主键索引，键值==不可能重复==；辅助索引则是普通索引，键值可能重复。

通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数
据文件中通过文件指针定位了具体的数据。==辅助索引==类似。



对于InnoDB引擎 ： **主键索引和辅助索引** 

主索引非叶子节点只记录  键值信息 ； 叶子节点是数据记录 

辅助索引 ： 非叶子节点只存储辅助索引对应的==索引字段==，而叶子节点的data字段==存储主键索引==的值。

> **为什么辅助索引存储主键信息？**
>
> ==保证数据的一致性和节省空间==。  比如订单表 和用户表 。在订单表中只存放用户的ID，而不是整个用户信息。方便维护 和节省空间 。 

也就意味着 ： 需要二次查询 ，先查询出主键信息，再从主键索引中找出数据值 。  ==**回表查询**==

但不是所有的都需要==二次==查询 ， 有个**覆盖索引**  :  【需要补充】



6. > **推荐使用整形自增而不是UUID？**

   - UUID是字符串，比整形耗费更多的==空间==
   - B+是按照顺序存储的，需要比较大小。整形数据运算比字符串==快==
   - 自增的索引在磁盘里的存储是连续的，读取也是连续的。UUID是随机的，不连续的。
   - 插入更新数据的时候，整形自增会在叶子节点的末尾建立新的节点。UUID会破坏B+树的结构，为了维持特性会进行重构，消耗更多的时间！



7. > **Hash 索引** 

   通过Hash算法(除数取余法，随机数法等)，将数据信息转化为hash值，存到相应的位置 。 如果发生hash碰撞，需要在取值是进行筛选。

   【为什么不用Hash索引？】  底层是hash表，key-value 结构 ，数据存储没有任何顺序关系。需要进行全表查询。如果有大量的重复键存在，哈希索引的效率会很低 【存在hash碰撞】。



8. > **哪些情况需要创建索引 ？ 那些不需要**？

   需要 ： 主键自动创建唯一索引 ； 查询频繁的 ； 

   不需要 ： 表数据太少 ； 经常增删改的表 ；数据重复的太多 ； 频繁更新的表



<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200831163912160.png" alt="image-20200831163912160" style="zoom:67%;" />

> **查询参加考试的同学（学号、姓名·······）**
>
> ==**思路：分析查询的字段来自那些表**==
>
> ==**确定使用那种查询？  7种**==
>
> ==**确定交叉点（那些数据是相同的）**==
>
> ==**判断条件 ：学生表ID = 成绩表ID**==





## MySQL 事务

> **事务ACID  隔离级别    脏读 不可重复读  幻读   MVCC**



9. > **ACID 事务的基本要素**

   - A ： 原子性  ：  事务的所有操作，要么全部完成，要么全部失败 ； 发生错误就回滚到初始状态
   - C ： 一致性 ： 事务的前后数据保证完整性
   - I ： 隔离性 ：  每个事务的执行，相互隔离，互不影响
   - D ： 持久性 ： 事务结束后，该事务所对数据库所作的更改便持久的保存在数据库之中，不会因为外界的原因导致数据丢失 。 



10. > **脏读、不可重复读、幻读**

    **脏读** ： 一个事务读取了另一个事务未提交的数据

    不可重复读： 事务A多次==**读取**==同一数据，事务B在事务A读取期间，对数据进行了更改，导致事务A读取的数据不一致   

       					(重点是==**修改**==的操作）
    
    **幻读** ： 事务A读取几行数据，事务B在这是插入了一些数据，随后事务A查询发现多了几行不存在的数据，跟发生幻觉一样。				    （重点是==**新增或删除**==的操作）

​       如何解决 ？ 加锁   MVCC【多版本并发控制】



11. > **事务的隔离级别**

    - READ-UNCOMMITTED(读未提交)  ： 最低级别  -- 允许读取未提交的事务的数据 ，造成 脏读 、 不可重复读 、 幻读

    - READ-COMMITED(读已提交)  ： 允许读取事务已经提交的事务 ， 可能造成 不可重复读 、 幻读

    - REPEATABLE - READ(可重复读)  ： 对同一数据的多次读取结果是一致的，可以防止脏读、不可重复读，可能会发生幻读

    - SERIALIZABLE (可串行化)  ： 最高隔离级别 ，完全服从ACID 。

      > **当然 事务隔离越严格 ，并发的副作用越小，但是代价越大。  事务的隔离实质上是事务在一定的程度上“串行化”进行，这是与“并发”是矛盾的。**

<img src="C:\Users\wangsw\AppData\Roaming\Typora\typora-user-images\image-20200901153617217.png" alt="image-20200901153617217" style="zoom:67%;" />



12. > **==MVCC==  多版本并发控制**

    为了提高数据库并发性能，用更好的方式去处理==读-写冲突==，做到即使有读写冲突时，也能做到==不加锁，非阻塞并发读==

    **读数据时** ： 如何让A读到的数据是一致的 ？ **解决数据库读一致性的问题**

    1.  **加锁** ； 当有其他事务对读取的数据进行操作时，加锁，其他事务读取时需要等待，操作数据结束后，才能读取成功。
    2. **MVCC** ； 不需要加锁 ，通过一定机制生成某个请求时间点的**数据快照**，不管事务的执行时间多长，看到的数据都是一致的；从用户看来是某个数据的不同的版本。



13. > **InoDB的MVCC 实现机制**

    简述MVCC实现的过程 ：   在每条记录的后面**保存两个隐藏的列** ： 一个保存数据的==创建时间== ， 一个保存数据的==过期时间==，这里记录的是系统的版本号 ，每开启一个事务，版本号会递增 

    1.  select 操作  ： 
       - InnoDB 只会查找==**早于（等于）当前事务版本**==的数据行 。 可以确保事务读取的行，在事务开始之前就存在了，或者是事务自身插入或者更新的数据
       - 行的删除版本号 ， 要么还未定义 ，要么版本号==**大于**==该事务的版本 ，保证数据在事务开始之前还未删除
    2. insert操作 ： 将新插入的行保存当前的版本号为行版本号
    3. delete操作 ：将删除的行保存当前版本号为删除版本号
    4. update操作 是 insert  和 delete的组合 ：  将当前的版本号作为行版本号 ； delete 则保存当前版本号 为原来行 作为删除的标识 。
    5. ==**不用加锁**==也能达到要求 ，但是需要额外的存储空间。



14. > **事务的日志**

    InnoDB使用日志来减少事务的开销 。

    因为事务修改数据和索引会映射到表空间的==随机位置==，需要很多的==随机IO==

    > - 使用日志把随机IO变为==顺序IO== ，一旦日志安全写到磁盘，事务就持久化了，即使断电也可以重放日志恢复已经提交的事务
    > - InnoDB 后台线程只能的刷新数据到数据文件。这个线程可以批量组合写入，使得数据写更==顺序==，提高效率



1. ​	使用了日志，修改数据时只需要修改其内存拷贝，再把修改行为持久在事务日志中，不需要每次都持久到	磁盘中
2. ​    事务日志持久之后，内存中修改的数据可以在后台==慢慢刷回==到磁盘中
3. ​    如果事务日志已经持久化，硬盘数据还没有修改的时候，断电后，引擎会在重启之后自动恢复这些数据



15. > **事务的隔离性是通过锁实现的，一致性、原子性、持久性是通过事务日志实现的**   如何实现的？？

    事务的日志分为   ==重做日志 (redo)==和==回滚日志(undo)==

    - **redo（重做日志）  【保证数据的原子性和==持久化==】**

      在InnoDB中，事务的日志通过重做日志和日志缓冲实现的。 事务的记录是==顺序追加==的

      事务开启时，事务的操作都会写入缓冲日志之中；在事务==提交之前==，==缓冲日志==提前==刷新磁盘==上。

      【==**日志先行**==】

      当事务==提交之后==， 将缓冲的数据慢慢刷新到磁盘上。如果此时数据库宕机，再重启之后，根据redo的日志，将数据库恢复到之前的状态。未完成的事务继续提交。

    - **undo （回滚日志） ** 【保证数据的==一致性==】

      为事务回滚服务的。 undo 记录了数据在每个操作前的状态，如果需要回滚，就根据undo日志进行回滚。 单个事务只会回滚当前事务的操作，不影响其他事务。

      ==**注意 ：**==  两种日志均是一种恢复操作 。 redo 是 恢复提交事务修改的页操作 ， undo 是回滚行记录到特定版本 。 redo 记录 的物理日志 ，记录页的修改操作 ； undo  是逻辑日志 ， 记录旧数据的行记录

==MySQL的 日志==  ： **错误日志 ； 查询日志 ； 慢查询日志 ； 二进制日志 ； 中继日志  ； 事务日志** 



## MySQL 锁机制

16. > **MySQL 锁机制**

    - 数据操作的类型分类 ：  

      ​	读锁【==共享锁==】 :   针对同一份数据 ， 多个读操作可以==同时进行==，不会相互影响

      ​	写锁【==排他锁==】 :   在写操作没有完成前，它会==阻断==其他写锁 和读锁

    - 操作的粒度分类 ：

      ​	表级锁 ： ==开销小== ，加锁快 。发生锁冲突的==概率最高== ，并发度最低。

      ​	行级锁 ： 开销==大==，加锁慢 。会出现死锁 ；发生锁冲突的概率最小，并发度高

      ​	页面锁 ： 开销和加锁时间介于表锁和行锁之间；粒度介于两者之间，并发度一般



17. >  **InnoDB 行锁** 

    实现了以下两种类型的行锁 ： 
    
    - ==共享锁== ： 允许一个事务去读一行 ，==阻止其他事务==获取相同数据集的排他锁
    - ==排他锁== ： 允许获得排他锁的事务更新数据，==阻止其他事==务取得相同数据集的共享读锁和排他写锁



​	乐观锁 和悲观锁 是两种并发控制的思想，用于**解决丢失更新问题**。 ： 事务A和B基于选定的值更新该执行时，由于彼此都不知																												对方的存在，会导致==更新丢失==的问题。

- ​	乐观锁 ： 假定不会发生更新冲突 ，处理数据的过程中==**不会加锁**==，只是在更新数据的时候，根据版本号或者时间戳来判断是  					否有冲突，有则处理，无则提交事务。

  > 当事务要更改数据时，会将数据的==版本==也读出来(==V1==)。当前事务对数据变动完毕==想要提交时==，再次读取该数据的版本号(==V2)==，如果 V1 =V2就提交更新，并且==版本号+==1 ；说明数据更改了。如果==不相等==，==不允许提交==更新，一般通知用户重新操作，直到成功为止 。
  >
  > ==ABA 问题== ：

- ​    悲观锁  :    假定会发生冲突，访问、处理数据==加排他锁==，在整个数据处理中锁定数据，事务提交或回滚后才释放锁。

  ​                     悲观锁是由数据库实现的。



18. > **死锁**

    死锁： 两个或多个事务在在资源上相互占用 ， 并请求对方占用的资源 ，而导致恶性循环

    **如何解决的 ？** 

    > 1.   **检测死锁  ：**
    >
    >      数据库有死锁检测和死锁超时的机制，检测到死锁就返回一个错误
    >
    > 2.   **死锁恢复 ：** 
    >
    >      死锁发生后，只有部分或完全回滚一个事务，才能打破死锁 。 InnoDB 目前的处理方法 ： 
    >
    >      将持有==最少的行级排他锁==的事务进行回滚。 最后只需要执行因死锁回滚的事务即可。
    >
    > 3.   死锁影响性能 ：  影响性能而不是产生严重的错误 。在高并发的系统上，多个线程等待同一个锁，导致速度变慢。
    >
    > 4.   MyISAM 获取的是全部锁，不会产生死锁
    >
    > 5.   InnoDB 避免死锁 ： 事务中，如果要更新数据，应==尽量申请足够级别的锁==，即排他锁。而不是先获取共享锁，更新时
    >
    >      获取排他锁。获取排它锁时，可能有其他事务获取了相同数据集的共享锁。这时可能会==造成死锁==
    >
    >    -   事务需要修改表，每个事务应该==以相同的顺序获取锁==，大大降低死锁发生的概率。



## MySQL调优



## MySQL分区分库分表

水平拆分  垂直拆分







## 主从复制

解决分库分表的数据一致性和同步问题。 ==**配主从**==



























